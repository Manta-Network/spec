\lsection{Design}{design}
\subsection{Ceremony Protocol}

Here we describe the MPC protocol for the trusted setup ceremony. This is a protocol for $N$ contributors $C_1, \ldots C_N$ to participate in the computation of the public parameters $\sigma$. Because the participants must contribute in serial, we use a central \Coordinator{} to order the participants and check their contributions. We emphasize that the \Coordinator{} exists solely to help organize the ceremony and has no effect on the security properties of the MPC.

The protocol is initialized by the \Coordinator{} and proceeds in repeated rounds, in which the \Coordinator{} and a \Contributor{} exchange messages. The messaging protocol is described in Section \ref{sec: MessagingProtocol}.

\subsubsection*{Initialization}

The \Coordinator{} computes an initial state $\sigma_0$ and challenge point $c_0$ as 
\begin{equation*}
    (\sigma_0, c_0) =  \initialize{}(\text{circuits, KZG parameters})
\end{equation*} 
The inputs to \initialize{} are the R1CS descriptions \eqref{eqn: r1cs} of some ZK circuits and modified KZG parameters \eqref{eq: kzg} (the output of a prior Phase 1 ceremony). The function \initialize{} computes $\sigma_0$, a Groth16 proving key with $\delta = 1$ (see \eqref{eq: prover_key}), and an initial challenge point $c_0$.

Note that \initialize{} is deterministic and the circuit descriptions and KZG parameters are public. Therefore any observer may verify that \Coordinator{} completed this step correctly.

\subsubsection*{Contribution Round}

The $n^{\text{th}}$ round of contribution begins with the state $\sigma_{n-1}$ and challenge $c_{n-1}$ of the previous round. \Contributor{} $C_n$ will interact with \Coordinator{} to produce the next state $\sigma_{n}$ and a proof $\pi_{n}$ that it was computed according to the protocol. The round consists of these steps:

\begin{enumerate}
\item \Coordinator{} sends $(\sigma_{n-1}, c_{n-1})$ to \Contributor{} $C_n$.
\item \Contributor{} computes $(\sigma_n, \pi_n) = $ \contribute{}$(\sigma_{n-1}, c_{n-1})$. The \contribute{} function must:
    \begin{enumerate}
        \item Sample $\delta_n \in \mathbb{F}$ randomly
        \item Compute contribution (TODO: ref. def.)
        \item Generate proof (TODO: ref. def.)
        \item Remove $\delta_n$ from memory
    \end{enumerate}
\item \Contributor{} sends $(\sigma_n, \pi_n)$ to \Coordinator{}
\item \Coordinator{} computes \verify{}$(\sigma_{n-1}, c_{n-1}, \sigma_n, \pi_n)$. This checks that the \Contributor{} has formed $\sigma_n$ from $\sigma_{n-1}$ according to the protocol.
    \begin{enumerate}
        \item If the check fails, \Coordinator{} rejects this contribution. Nothing is added to the transcript and the \Coordinator{} proceeds to next round with state and challenge unchanged ($\sigma_n = \sigma_{n-1}$ and $c_n = c_{n-1}$).
        \item Otherwise, \Coordinator{} computes challenge $c_n = $ \challenge$(\sigma_{n-1}, c_{n-1}, \sigma_n, \pi_n)$ and records $\sigma_n, \pi_n, c_n$ to the \Transcript{}.
    \end{enumerate}
\item \Coordinator{} proceeds to next round with $(\sigma_n, c_n)$.
\end{enumerate}
This process repeats until all \Contributor{}s have made their contribution. At the end (assuming all contributions were valid) we have a Groth16 prover key $\sigma$ with $\delta = \delta_1 \cdot \delta_2 \cdot \ldots \cdot \delta_n $ and a \Transcript{} $T = \{ (\sigma_i, \pi_i, c_i) \}_{i=1}^N $ recording all contributions to the ceremony and allowing a third-party to verify that $\sigma$ was computed according to protocol.

\subsection{Messaging Protocol}\label{sec: MessagingProtocol}
TODO 

\subsection{Server State Machine}

The \Coordinator{} role is performed by a central server. The \Coordinator{}'s duties are to enforce the MPC protocol and organize the contributions. To enforce the MPC protocol, the \Coordinator{} performs:
\begin{itemize}
    \item Parameter Initialization: a reproducible initial state $\sigma_0$ is computed from public data.
    \item Contribution Verification: each contribution to the ceremony is checked to conform to the MPC protocol.
    \item Contribution Archival: each successful contribution to the ceremony is recorded, together with a cryptographic proof that it conforms to the MPC protocol.
\end{itemize}
To organize the contributions, the \Coordinator{} performs:
\begin{itemize}
    \item Registry Maintenance: a registry of participants records who is authorized to submit contributions to the ceremony and the public keys with which they will sign their messages.
    \item Signature verification: all messages from a \Contributor{} to the \Coordinator{} will be signed.
    \item Queue management: during the ceremony, participants are ordered in a queue.
\end{itemize}

\subsubsection*{State}
A state machine acts as \Coordinator{}. Its state consists of:
\begin{itemize}
    \item \Registry{}: For each participant, a record of their public signing key and whether they have already contributed to the ceremony.
    \item \MpcState{}: The current pair $(\sigma_n, c_n)$ (see above). 
    \item \Transcript{}: The history of MPC States and proofs (see above).
    \item \Queue{}: an ordering of the participants waiting to contribute. This may be a priority queue, if desired.
    \item \TimedLock{}: a lock is given to the participant at the front of the queue while they compute their contribution. This lock times out after a specified duration and drops the participant from the queue.
\end{itemize}

\subsubsection*{State Changes}
The state of the machine may change by calls to these functions:
\begin{itemize}
    \item \initialize{}: set \MpcState{} to $(\sigma_0, c_0)$ (see above).
    \item \enqueue{}(\ParticipantId{}): check that participant is registered and has not already contributed. If so, add to end of \Queue{}.
    \item \verify{}$(\sigma_{n-1}, c_{n-1}, \sigma_n, \pi_n)$: check that the latest contribution conforms to MPC protocol. If so, compute challenge $c_n$, update \MpcState{} to $(\sigma_n, c_n)$, and update \Transcript{} and \Registry. Update \Queue{} and \TimedLock{}.
\end{itemize}

\subsubsection*{Operation}
The \Coordinator{} state machine initializes its state and then listens for messages and processes these according to the messaging protocol (see above). Two types of messages are recognized, \QueryRequest{} and \UpdateRequest{}. The state machine responds in the following way to each request:
\begin{itemize}
    \item \QueryRequest{}
    \begin{enumerate}
        \item Parse \ParticipantId{} from request. 
        \item Consult \Registry{}, confirm participant is registered and has not contributed. 
        \item Consult \Queue{}; if participant is not in \Queue{}, call \enqueue{}.
        \item Consult \Queue{}; if participant is at front of \Queue{}, send a message containing \MpcState{} to participant and set \TimedLock{}. Otherwise, send participant a message containing their current position in \Queue{}.
    \end{enumerate}
    \item \UpdateRequest{}
    \begin{enumerate}
        \item Parse \ParticipantId{} from request. Check that the \TimedLock{} refers to this participant.
        \item Parse state, proof $(\sigma_n, \pi_n)$ from request. 
        \item Call \verify{}$(\sigma_{n-1}, c_{n-1}, \sigma_n, \pi_n)$.
    \end{enumerate}
\end{itemize}
If any of the above checks do not pass, the \Coordinator{} responds with an appropriate error message.

TODO: Flow chart would express this nicely

\subsection{Client State Machine}

The duty of a \Contributor{} is to contribute according to the MPC protocol. To this end, a client state machine performs:
\begin{itemize}
    \item Ed25519 Keypair Generation: each \Contributor{} generates their own signature credentials.
    \item Message Signing: messages to \Coordinator{} are signed.
    \item Contribution: formed according to MPC protocol.
\end{itemize}

\subsubsection*{State}
The state of this machine is an immutable Ed25519 private key. The machine also needs access to some random oracle to perform keypair generation and contribution.

This state is initialized by \generatekeypair{}, which generates an Ed25519 private/public keypair. Note that the same state can later be recovered by prompting users to enter their private key or seed phrase.

\subsubsection*{Operation}

\begin{enumerate}
    \item Initialize state.
    \item Send signed \QueryRequest{} to \Coordinator{}. Await response containing \MpcState{} and challenge, $(\sigma_{n-1}, c_{n-1})$.
    \item Compute $(\sigma_n, \pi_n) = $ \contribute{}$(\sigma_{n-1}, c_{n-1})$.
    \begin{enumerate}
        \item Sample random $\delta$
        \item Transform $\sigma_{n-1}$ by $\delta$ to get $\sigma_n$
        \item Produce ratio proof $\pi_n$ 
    \end{enumerate}
    \item Send signed \UpdateRequest{} to \Coordinator{}. Await response confirming submission.
    \item Clear $\delta$ from memory.
\end{enumerate}

Steps 3a and 5 of this protocol have famously led to participants sampling $\delta$ using randomness from Chernobyl and later smashing their computers to clear it from memory. An ambitious participant can easily modify our implementation (todo: cite code) to accommodate exotic sources of randomness.