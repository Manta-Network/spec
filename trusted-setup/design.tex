\lsection{Design}{design}
\subsection{Ceremony Protocol}

Here we describe the MPC protocol for the trusted setup ceremony. This is a protocol for $N$ contributors $C_1, \ldots C_N$ to participate in the computation of the public parameters $\sigma$. Because the participants must contribute in serial, we use a central \Coordinator{} to order the participants and check their contributions. We emphasize that the \Coordinator{} exists solely to help organize the ceremony and has no effect on the security properties of the MPC.

The protocol is initialized by the \Coordinator{} and proceeds in repeated rounds, in which the \Coordinator{} and a \Contributor{} exchange messages. The messaging protocol is described in Section \ref{sec: MessagingProtocol}.

\subsubsection*{Initialization}

The \Coordinator{} calls a function \initialize{} whose inputs are the R1CS descriptions \eqref{eqn: r1cs} of some ZK circuits and modified KZG parameters \eqref{eq: kzg} (the output of a prior Phase 1 ceremony). The function \initialize{} computes from these inputs a Groth16 proving key with $\delta = 1$ (see \eqref{eq: prover_key}) and an initial challenge point. We denote these $\sigma_0$ and  $c_0$, respectively.

\subsubsection*{Contribution Round}

The $n^{\text{th}}$ round of contribution begins with the state $\sigma_{n-1}$ and challenge $c_{n-1}$ of the previous round. \Contributor{} $C_n$ will interact with \Coordinator{} to produce the next state $\sigma_{n}$ and a proof $\pi_{n}$ that it was computed according to the protocol. The round consists of these steps:

\begin{enumerate}
\item \Coordinator{} sends $(\sigma_{n-1}, c_{n-1})$ to \Contributor{} $C_n$.
\item \Contributor{} computes $(\sigma_n, \pi_n) = $ \contribute{}$(\sigma_{n-1}, c_{n-1})$. The \contribute{} function must:
    \begin{enumerate}
        \item Sample $\delta_n \in \mathbb{F}$ randomly
        \item Compute contribution (TODO: ref. def.)
        \item Generate proof (TODO: ref. def.)
        \item Remove $\delta_n$ from memory
    \end{enumerate}
\item \Contributor{} sends $(\sigma_n, \pi_n)$ to \Coordinator{}
\item \Coordinator{} computes \verify{}$(\sigma_{n-1}, c_{n-1}, \sigma_n, \pi_n)$. This checks that the \Contributor{} has formed $\sigma_n$ from $\sigma_{n-1}$ according to the protocol.
    \begin{enumerate}
        \item If the check fails, \Coordinator{} rejects this contribution. Nothing is added to the transcript and the \Coordinator{} proceeds to next round with state and challenge unchanged ($\sigma_n = \sigma_{n-1}$ and $c_n = c_{n-1}$).
        \item Otherwise, \Coordinator{} computes challenge $c_n = $ \challenge$(\sigma_{n-1}, c_{n-1}, \sigma_n, \pi_n)$ and records $\sigma_n, \pi_n, c_n$ to the \Transcript{}.
    \end{enumerate}
\item \Coordinator{} proceeds to next round with $(\sigma_n, c_n)$.
\end{enumerate}
This process repeats until all \Contributor{}s have made their contribution. At the end (assuming all contributions were valid) we have a Groth16 prover key $\sigma$ with $\delta = \delta_1 \cdot \delta_2 \cdot \ldots \cdot \delta_n $ and a \Transcript{} $T = \{ (\sigma_i, \pi_i, c_i) \}_{i=1}^N $ recording all contributions to the ceremony and allowing a third-party to verify that $\sigma$ was computed according to protocol.

\subsection{Messaging Protocol}\label{sec: MessagingProtocol}
TODO 

\subsection{Server State Machine}
Responsibilities:
\begin{itemize}
    \item Parameter Initialization (see above)
    \item Contribution verification
    \item Signature verification 
    \item Registry maintenance
    \item Queue management
    \item Contribution archive 
\end{itemize}
State: 
\begin{itemize}
    \item Registry: Registry
    \item MpcState: (ProverKey x Challenge x Proof) x no. circuits (TODO: How explicitly should be mention the multiple parallel circuits?)
    \item Transcript: ( ditto ) x no. rounds
\end{itemize}
Methods:
\begin{itemize}
    \item Initialize
    \item Enqueue 
    \item ParseMessage
    \item VerifyContribution
    \item SendMessage
\end{itemize}
Operation:
\begin{enumerate}
    \item Initialize
    \item Concurrent Loop: Coordinate Contributions (TODO: Flow chart)
    \begin{enumerate}
        \item ParseMessage (contribute). 
        \item Consult Registry, SendMessage (either QueuePosition or MpcState) 
        \item Await ContributionResponse, ParseMessage to yield Contribution
        \item Verify Contribution 
        \item Update MpcState, update Registry
        \item Add Contribution to Transcript
    \end{enumerate}
    \item Concurrent Loop: Queue Management
    \begin{enumerate}
        \item ParseMessage (JoinQueue), yield ParticipantId
        \item Consult Registry
        \item Enqueue (if Participant has not contributed)
    \end{enumerate}
\end{enumerate}

\subsection{Client State Machine}
Responsibilities:
\begin{itemize}
    \item Ed25519 keypair generation
    \item Message Signing
    \item Contribution Computation
\end{itemize}
State:
\begin{itemize}
    \item Keypair: SignatureKeypair
    \item Randomness: PRNG
\end{itemize}
Methods:
\begin{itemize}
    \item GenerateKeypair
    \item RequestState
    \item Contribute
\end{itemize}
Operation:
\begin{enumerate}
    \item GenerateKeypair, initialize own state
    \item RequestState: send signed message asking for the MpcState
    \item Await StateResponse 
    \item Contribute, send signed ContributeRequest
    \item Output Attestation
\end{enumerate}
(Mention nonce management? Or is that an internal detail to signatures?)