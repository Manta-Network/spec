\lsection{Concrete Protocol}{concrete-protocol}

We define the instantiation of the abstract protocol in this section.

\subsection{Preliminaries}

Two of the major building blocks of the protocol are elliptic curve cryptography and finite field algebraic hash functions.

\subsubsection{Elliptic Curve Cryptography}

Because we use a Zero-Knowledge Proving System, we want the cryptographic constructions below to be \emph{ZKP-friendly}. To denote the elliptic-curve constructions that live inside of a ZKP system we use the term ``embedded'' and denote the embedded elliptic curve group $\mathbb{G}$ with scalar field $\mathbb{F}$ for the following sections. See \autoref{def:concrete-zkp} for more.

\subsubsection{Poseidon Permutation}

The \Poseidon{} Permutation \cite{KRRS21USENIX} is a finite field cryptographic primitive that can be used in lots of different contexts, like hash functions, commitment schemes, and symmetric encryption. \Poseidon{} plays a fundamental role in simplifying the protocol and reducing the overall cost of the Zero-Knowledge circuits. The \Poseidon{} Permutations are a family of hash functions with the following signature:
\[\Poseidon_k : \mathbb{F}^k \to \mathbb{F}\]
We make use of \Poseidon{} for a few values of $k$ in the concrete protocol below.

\subsection{Concrete Cryptographic Schemes}

\begin{definitiontoc}{Commitment Schemes}
    The protocol features two different commitment schemes: $\COM^{\UTXO}$ the \UTXO{} Commitment Scheme and $\COM^{\VN}$ the Void Number Commitment Scheme. Both commitment schemes use \Poseidon{} as the cryptographic primitive. The \UTXO{} uses an arity-4 \Poseidon{} with the following mapping:
    \[\COM^{\UTXO}(\esk, \pk, \asset) := \Poseidon_4(\esk, x(\pk), \asset.\ID, \asset.\VALUE)\]
    For the Void Number Commitment Scheme we use an arity-2 \Poseidon{} with the following mapping:
    \[\COM^{\VN}(\sk, \cm) := \Poseidon_2(\sk, \cm)\]
\end{definitiontoc}

\begin{definitiontoc}{Key-Agreement Scheme}
    For $\KA$, we use a Diffie-Hellman Key Exchange over $(\mathbb{G}, \mathbb{F})$:
    \begin{align*}
        \KA.\derive(x)   &: \mathbb{F} \to \mathbb{G}                   := x \cdot G \\
        \KA.\agree(x, y) &: \mathbb{F} \times \mathbb{G} \to \mathbb{G} := x \cdot y
    \end{align*}
    where $G$ is a fixed public point.
\end{definitiontoc}

\begin{definitiontoc}{Symmetric-Key Encryption Scheme}
    For $\SYM$, we use symmetric-key encryption scheme: AES-GCM~\cite{rfc5288} with magic-number nonce and no associated data. Note that it is safe to reuse the nonce here because we assume that the encryption key is only used once.
\end{definitiontoc}

\begin{definitiontoc}{Key-Derivation Functions}
    For $\KDF$, we use Blake2s~\cite{rfc7693} with magic-number salt.
\end{definitiontoc}

\begin{definitiontoc}{Dynamic Cryptographic Accumulator}
    For $\DCA$, we use a Merkle Tree with of arity-2 with \Poseidon{} as the inner node combining hash function.

    \TODO{dynamic cryptographic accumulator: Merkle Tree with Poseidon hashes (incremental tree for the ledger is an optimization since it only needs to know enough to compute the accumulated value)}
\end{definitiontoc}

\begin{definitiontoc}{Non-Interactive Zero-Knowledge Proving System} \label{def:concrete-zkp}
    For $\NIZK$, the protocol can use any non-interactive zero-knowledge proving system like Groth16 \cite{KRRS21USENIX} and/or PLONK/PLONKUP~\cite{plonk,plonkup}. 
\end{definitiontoc}

