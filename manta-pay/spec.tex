\documentclass[a4paper]{article}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[margin=0.8in]{geometry}
\usepackage[
    colorlinks=true,
    linkcolor=blue,
    filecolor=blue,
    urlcolor=blue,
    pdfpagemode=FullScreen,
]{hyperref}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{commath}
\usepackage{float}
\usepackage{parskip}
\usepackage{tikz-cd}
\usepackage{wrapfig}

\newcommand{\subsubsubsection}[1]{\paragraph{#1}}
\newcommand{\subsubsubsubsection}[1]{\subparagraph{#1}}
\setcounter{secnumdepth}{4}
\setcounter{tocdepth}{4}

\def\sectionautorefname{$\S$}
\def\subsectionautorefname{$\S$}
\def\subsubsectionautorefname{$\S$}
\def\subsubsubsectionautorefname{$\S$}

\newcommand{\lsection}[2]{\def\sectionlabel{#2} \section{#1}\label{sec:#2}}
\newcommand{\lsubsection}[2]{\def\sectionlabel{#2} \subsection{#1}\label{sec:#2}}
\newcommand{\lsubsubsection}[2]{\def\sectionlabel{#2} \subsubsection{#1}\label{sec:#2}}
\newcommand{\lsubsubsubsection}[2]{\def\sectionlabel{#2} \subsubsubsection{#1}\label{sec:#2}}
\newcommand{\lsubsubsubsubsection}[2]{\def\sectionlabel{#2} \subsubsubsubsection{#1}\label{sec:#2}}
\newcommand{\TODO}[1]{{\color{red}\textbf{TODO}}: #1}

\floatstyle{boxed} 
\restylefloat{figure}

\theoremstyle{definition}
\newtheorem{definition}{Definition}[subsection]
\newtheorem*{definition*}{Definition}

\newcommand{\dash}{{\textrm{--}}}
\renewcommand{\abs}[1]{\left|#1\right|}
\newcommand{\Prob}[2]{\mathrm{Pr}\scalebox{0.88}{\ensuremath{\left[\!\!\begin{array}{c}#1\end{array} \middle| \begin{array}{l}#2\end{array}\!\!\right]}}}

\newcommand{\Alice}{{\textsf{Alice}}}
\newcommand{\AssetId}{{\textsf{AssetId}}}
\newcommand{\AssetValue}{{\textsf{AssetValue}}}
\newcommand{\Asset}{{\textsf{Asset}}}
\newcommand{\Bob}{{\textsf{Bob}}}
\newcommand{\Bool}{{\textsf{Bool}}}
\newcommand{\COM}{{\textsf{COM}}}
\newcommand{\CRH}{{\textsf{CRH}}}
\newcommand{\Charlie}{{\textsf{Charlie}}}
\newcommand{\CheckProof}{{\textsf{CheckProof}}}
\newcommand{\Ciphertext}{{\textsf{Ciphertext}}}
\newcommand{\Concat}{{\textsf{Concat}}}
\newcommand{\Decrypt}{{\textsf{Decrypt}}}
\newcommand{\DerivePublic}{{\textsf{DerivePublic}}}
\newcommand{\Derive}{{\textsf{Derive}}}
\newcommand{\EncryptedNote}{{\textsf{EncryptedNote}}}
\newcommand{\Encrypt}{{\textsf{Encrypt}}}
\newcommand{\EntropySource}{{\textsf{EntropySource}}}
\newcommand{\Enumerate}{{\textsf{enumerate}}}
\newcommand{\FAIR}{{\textsf{FAIR}}}
\newcommand{\False}{{\textsf{False}}}
\newcommand{\GetAccumulatorAndZeroes}{{\textsf{GetAccumulatorAndZeroes}}}
\newcommand{\GetProof}{{\textsf{GetProof}}}
\newcommand{\HASH}{{\textsf{HASH}}}
\newcommand{\ID}{{\textsf{id}}}
\newcommand{\IES}{{\textsf{IES}}}
\newcommand{\Input}{{\textsf{Input}}}
\newcommand{\KA}{{\textsf{KA}}}
\newcommand{\KDF}{{\textsf{KDF}}}
\newcommand{\KDIV}{{\textsf{KDIV}}}
\newcommand{\KeyDistribution}{{\textsf{KeyDistribution}}}
\newcommand{\Key}{{\textsf{Key}}}
\newcommand{\MantaDAP}{{\Manta{}_{\texttt{DAP}}}}
\newcommand{\MantaPay}{{\textsf{MantaPay}}}
\newcommand{\Manta}{{\textsc{Manta}}}
\newcommand{\MerkleTree}{{\textsf{MerkleTree}}}
\newcommand{\Message}{{\textsf{Message}}}
\newcommand{\Mint}{{\textsf{Mint}}}
\newcommand{\Next}{{\textsf{Next}}}
\newcommand{\None}{{\textsf{None}}}
\newcommand{\Option}{{\textsf{Option}}}
\newcommand{\Output}{{\textsf{Output}}}
\newcommand{\PATH}{{\textsf{path}}}
\newcommand{\PRF}{{\textsf{PRF}}}
\newcommand{\Path}{{\textsf{Path}}}
\newcommand{\Plaintext}{{\textsf{Plaintext}}}
\newcommand{\PrepareZeroes}{{\textsf{PrepareZeroes}}}
\newcommand{\PrivateTransfer}{{\textsf{PrivateTransfer}}}
\newcommand{\Proof}{{\textsf{Proof}}}
\newcommand{\Prop}{{\textsf{Prop}}}
\newcommand{\Prove}{{\textsf{Prove}}}
\newcommand{\ProvingKey}{{\textsf{ProvingKey}}}
\newcommand{\PublicAddress}{{\textsf{PublicAddress}}}
\newcommand{\PublicInput}{{\textsf{PublicInput}}}
\newcommand{\PublicKey}{{\textsf{PublicKey}}}
\newcommand{\PublicLedger}{{\textsf{PublicLedger}}}
\newcommand{\ROOT}{{\textsf{root}}}
\newcommand{\ReceiverPost}{{\textsf{ReceiverPost}}}
\newcommand{\Receiver}{{\textsf{Receiver}}}
\newcommand{\ReceivingKey}{{\textsf{ReceivingKey}}}
\newcommand{\Reclaim}{{\textsf{Reclaim}}}
\newcommand{\Root}{{\textsf{Root}}}
\newcommand{\SYM}{{\textsf{SYM}}}
\newcommand{\Sample}{{\textsf{Sample}}}
\newcommand{\SecretInput}{{\textsf{SecretInput}}}
\newcommand{\SecretKey}{{\textsf{SecretKey}}}
\newcommand{\SeededRng}{{\textsf{SeededRng}}}
\newcommand{\SenderPost}{{\textsf{SenderPost}}}
\newcommand{\Sender}{{\textsf{Sender}}}
\newcommand{\SharedSecret}{{\textsf{SharedSecret}}}
\newcommand{\ShieldedAddress}{{\textsf{ShieldedAddress}}}
\newcommand{\ShieldedAssetPool}{{\textsf{ShieldedAssetPool}}}
\newcommand{\ShieldedIdentity}{{\textsf{ShieldedIdentity}}}
\newcommand{\Sink}{{\textsf{Sink}}}
\newcommand{\Some}{{\textsf{Some}}}
\newcommand{\Source}{{\textsf{Source}}}
\newcommand{\SpendingKey}{{\textsf{SpendingKey}}}
\newcommand{\Statement}{{\textsf{Statement}}}
\newcommand{\TransferPost}{{\textsf{TransferPost}}}
\newcommand{\Transfer}{{\textsf{Transfer}}}
\newcommand{\TrapdoorDistribution}{{\textsf{TrapdoorDistribution}}}
\newcommand{\Trapdoor}{{\textsf{Trapdoor}}}
\newcommand{\True}{{\textsf{True}}}
\newcommand{\Type}{{\textsf{Type}}}
\newcommand{\UTXO}{{\textsf{UTXO}}}
\newcommand{\VALUE}{{\textsf{value}}}
\newcommand{\Value}{{\textsf{Value}}}
\newcommand{\VerifyingKey}{{\textsf{VerifyingKey}}}
\newcommand{\Verify}{{\textsf{Verify}}}
\newcommand{\ViewingKey}{{\textsf{ViewingKey}}}
\newcommand{\VoidNumber}{{\textsf{VoidNumber}}}
\newcommand{\Void}{{\textsf{Void}}}
\newcommand{\ZKPS}{{\textsf{ZKPS}}}
\newcommand{\agree}{{\textsf{agree}}}
\newcommand{\allocated}{{\textsf{allocated}}}
\newcommand{\asset}{{\textsf{asset}}}
\newcommand{\cm}{{\textsf{cm}}}
\newcommand{\commit}{{\textsf{commit}}}
\newcommand{\contains}{{\textsf{contains}}}
\newcommand{\decrypt}{{\textsf{decrypt}}}
\newcommand{\derive}{{\textsf{derive}}}
\newcommand{\encrypt}{{\textsf{encrypt}}}
\newcommand{\hash}{{\textsf{hash}}}
\newcommand{\keys}{{\textsf{keys}}}
\newcommand{\len}{{\textsf{len}}}
\newcommand{\note}{{\textsf{note}}}
\newcommand{\opk}{{\textsf{opk}}}
\newcommand{\osk}{{\textsf{osk}}}
\newcommand{\pk}{{\textsf{pk}}}
\newcommand{\prove}{{\textsf{prove}}}
\newcommand{\public}{{\textsf{public}}}
\newcommand{\pub}{{\textsf{pub}}}
\newcommand{\receiver}{{\textsf{receiver}}}
\newcommand{\receive}{{\textsf{receive}}}
\newcommand{\remainder}{{\textsf{remainder}}}
\newcommand{\rk}{{\textsf{rk}}}
\newcommand{\satisfying}{{\textsf{satisfying}}}
\newcommand{\secret}{{\textsf{secret}}}
\newcommand{\sender}{{\textsf{sender}}}
\newcommand{\sink}{{\textsf{sink}}}
\newcommand{\sk}{{\textsf{sk}}}
\newcommand{\source}{{\textsf{source}}}
\newcommand{\spend}{{\textsf{spend}}}
\newcommand{\spent}{{\textsf{spent}}}
\newcommand{\trapdoor}{{\textsf{trapdoor}}}
\newcommand{\verify}{{\textsf{verify}}}
\newcommand{\view}{{\textsf{view}}}
\newcommand{\vk}{{\textsf{vk}}}
\newcommand{\vn}{{\textsf{vn}}}

\title{\textbf{\MantaPay{} Protocol Specification}\\ v0.4.0}
\author{Shumo Chu and Brandon H. Gomes}
\date{\today}

\begin{document}
    
\maketitle

\begin{abstract}
    \MantaPay{} is an implementation of a \emph{decentralized anonymous payment} scheme based on the $\MantaDAP$ protocol outlined in the original \href{https://eprint.iacr.org/2021/743.pdf}{\Manta{} whitepaper}.
\end{abstract}
    
\tableofcontents

\lsection{Introduction}{introduction}

\TODO{add introductory remarks}

\lsection{Notation}{notation}

The following notation is used throughout this specification:

\begin{itemize}
    \item $\Type$ is the type of types\footnotemark{}.
    \item If $x : T$ then $x$ is a value and $T$ is a type, denoted $T : \Type$, and we say that $x$ \emph{has type} $T$.
    \item $\Bool$ is the type of booleans with values $\True$ and $\False$.
    \item For any types $A : \Type$ and $B : \Type$ we denote the \emph{type of functions} from $A$ to $B$ as $A \to B : \Type$.
    \item For any types $A : \Type$ and $B : \Type$ we denote the \emph{product type} over $A$ and $B$ as $A \times B : \Type$ with constructor $(\dash, \dash) : T \to (S \to T \times S)$.
    \item For any type $T : \Type$, we define $\Option(T) : \Type$ as the inductive type with constructors:
        \begin{align*}
            \None &: \Option(T) \\
            \Some &: T \to \Option(T)
        \end{align*}
    \item We denote the \emph{type of distributions} over a type $T : \Type$ as $\mathfrak{D}(T) : \Type$. A value $x$ sampled from $\mathfrak{D}(T)$ is denoted $x \sim \mathfrak{D}(T)$ and the fact that the value $x$ belongs to the range of $\mathfrak{D}(T)$ is denoted $x \in \mathfrak{D}(T)$. So namely, $y \in \set{x \,|\, x \sim \mathfrak{D}(T)} \leftrightarrow y \in \mathfrak{D}(T)$.
    \item Depending on the context, the notation $\abs{\,\cdot\,}$ denotes either the absolute value of a quantity, the length of a vector, the number of characters in a string, or the cardinality of a set.
\end{itemize}

\footnotetext{By \emph{type of types}, we mean the type of \emph{first-level} types in some family of type universes. Discussion of the type theory necessary to make these notions rigorous is beyond the scope of this paper.}

\lsection{Concepts}{concepts}

\subsection{Assets}

The \Asset{} is the fundamental currency object in the \MantaPay{} protocol. An asset $a : \Asset$ is a tuple
\[a = (a.\ID, a.\VALUE) : \AssetId \times \AssetValue\]
The \MantaPay{} protocol is a \emph{decentralized anonymous payment} scheme which facilitiates the private ownership and private transfer of \Asset{} objects. The \AssetId{} field encodes the type of currency being used, and the \AssetValue{} encodes how many units of that currency are being used, in the standard base unit of that currency.

Whenever an \Asset{} is being used in a public setting, we simply refer to it as an \Asset{}, but when the \AssetId{} and/or \AssetValue{} of a particular \Asset{} is meant to be hidden from public view, we refer to the \Asset{} as either, \emph{secret}, \emph{private}, \emph{hidden}, or \emph{shielded}.

\Asset{s} form the basic units of \emph{transactions} which consume \Asset{s} on input, transform them, and return \Asset{s} on output. To preserve the economic value stored in \Asset{s}, the sum of the input \AssetValue{s} must balance the sum of the output \AssetValue{s}, and all assets in a single transaction must have the same \AssetId{}\footnotemark{}. 

\footnotetext{It is beyond the scope of this paper to discuss transactions with inputs and outputs that feature different \AssetId{s}, like those that would be featured in a \emph{decentralized anonymous exchange}.}

\lsubsection{Addresses}{addresses}

In order for participants in the \MantaPay{} protocol to send and receive \Asset{s}, they must create secret and public \emph{addresses} according to an \emph{address scheme}. For \MantaPay{}, the address scheme consists of a \emph{spending key} $\sk$, a \emph{viewing key} $\vk$, and a \emph{receiving key} $\rk$. The keys have the following uses/properties:

\begin{itemize}
    \item Access to a receiving key $\rk$ represents the ability to send \Asset{s} to the owner of the associated $\sk$.
    \item Access to a viewing key $\vk$ represents the ability to reveal shielded \Asset{} information for \Asset{s} belonging to the owner of the associated $\sk$.
    \item Access to a spending key $\sk$ represents the ability to spend \Asset{s} that were received under the associated receiving key $\rk$.
\end{itemize}

See \autoref{sec:addresses-and-key-components} for more information on how these keys are constructed and used for spending, viewing, and receiving \Asset{s}.

\subsection{Ledger}

\begingroup
\setlength{\columnsep}{20pt}

\begin{wrapfigure}{r}[-10pt]{0.45\textwidth}
    \begin{center}
    \begin{tikzcd}
        \ShieldedAssetPool & & \\
            & \Transfer
                \arrow[r, "\spend"]
                \arrow[lu, leftrightarrow, start anchor = north west, end anchor = south east]
                \arrow[ld, leftrightarrow, start anchor = south west, end anchor = north east]
            & \Void \\
        \PublicLedger & &
    \end{tikzcd}
    \end{center}
    \caption{Lifecycle of an \Asset{}.}
\end{wrapfigure}

Ensuring that \Asset{s} maintain their economic value is not only dependent on transactions preserving inputs and outputs, but also that \Asset{s} are not \emph{double-spent}. The \emph{double-spending problem} can be solved by using a public ledger\footnotemark{} that keeps track of the flow of \Asset{s} from one participant to the other. Unfortunately, using a public ledger alone does not allow participants to remain anonymous, so \MantaPay{} extends the public ledger by adding a special account called the \ShieldedAssetPool{}. The \ShieldedAssetPool{} is responsible for keeping track of the \Asset{s} which have been anonymized by the protocol.

\Asset{s} can be in one of three states, \public{} (tracked by the \PublicLedger{}), \allocated{} (spendable subset of the \ShieldedAssetPool{}), or \spent{} (voided \Asset{s}). By way of the \autoref{sec:transfer-protocol} \Transfer{} Protocol, \Asset{s} can be sent to and from the \PublicLedger{} and the \ShieldedAssetPool{}.

The \ShieldedAssetPool{} is made up of four parts:

\begin{enumerate}
    \item \ShieldedAssetPool{} Balance: The \MantaPay{} ledger contains a collection of \Asset{s} which represent the combined economic value of the \ShieldedAssetPool{} and the \PublicLedger{}. The \ShieldedAssetPool{} Balance is the subset of this total value that has been anonymized by the \MantaPay{} protocol.
    \item \autoref{sec:ledger-utxo-set} \UTXO{} Set: A collection of claims to subsets of the \ShieldedAssetPool{}, each owned by participants of the \MantaPay{} protocol.
    \item \autoref{sec:ledger-encrypted-notes} \EncryptedNote{s}: For each \UTXO{} there is a matching \EncryptedNote{} which contains information necessary to spend the \Asset{}, which is commited in the \UTXO{}, but can only be decrypted by the recipient of the \Asset{}, specifically, the correct viewing key $\vk$. See \autoref{sec:addresses} for more.
    \item \autoref{sec:ledger-void-number-set} \VoidNumber{} Set: A collection of commitments keeping track of those \UTXO{s} which have participated in exactly one instance of the \Transfer{} Protocol.
\end{enumerate}

An \Asset{} is in the \public{} state if it belongs to the \PublicLedger{}. An \Asset{} is in the \allocated{} state if a \UTXO{} for the \Asset{} is a member of the \UTXO{} Set, but its matching \VoidNumber{} is \textbf{not} in the \VoidNumber{} Set. An \Asset{} is in the \spent{} state if it was \allocated{} in the past, but its matching \VoidNumber{} is now in the \VoidNumber{} Set.

The operation of the different parts of the \ShieldedAssetPool{} is elaborated in the following subsections.

\endgroup

\footnotetext{A public (or private) ledger is not enough to solve the \emph{double-spending problem}. A \emph{consensus mechanism} is also required to ensure that all participants agree on the current state of the ledger. The \emph{consensus mechanism} that secures the \MantaPay{} ledger is beyond the scope of this paper.}

\lsubsubsection{\UTXO{} Set}{ledger-utxo-set}

\lsubsubsection{\EncryptedNote{s}}{ledger-encrypted-notes}

\lsubsubsection{\VoidNumber{} Set}{ledger-void-number-set}

\lsection{Abstract Protocol}{abstract-protocol}

\subsection{Abstract Cryptographic Schemes}

\begin{definition}
    A \emph{commitment scheme} $\COM$ is defined by the schema:
    \begin{align*}
        \Trapdoor             &: \Type \\
        \Input                &: \Type \\
        \Output               &: \Type \\
        \TrapdoorDistribution &: \mathfrak{D}(\Trapdoor) \\
        \commit               &: \Trapdoor \times \Input \to \Output
    \end{align*}
    with the following properties:

    \begin{itemize}
        \item \textbf{Binding}: It is infeasible to find an $x, y : \Input$ and $r, s: \Trapdoor$ such that $x \ne y$ and $\commit(r,x) = \commit(s,y)$.
        \item \textbf{Hiding}: For all $x, y : \Input$, the distributions $\set{\commit(r,x) \,|\, r \sim \TrapdoorDistribution}$ and \\ $\set{\commit(r,y) \,|\, r \sim \TrapdoorDistribution}$ are \emph{computationally indistinguishable}.
    \end{itemize}

\textbf{Notation}: For convenience we refer to $\COM.\commit(r,x)$ by $\COM_r(x)$.
\end{definition}

\begin{definition}
A \emph{hash function} $\CRH$ is defined by the schema:
\begin{align*}
    \Input  &: \Type \\
    \Output &: \Type \\
    \hash   &: \Input \to \Output
\end{align*}
with the following properties:

\begin{itemize}
    \item \textbf{Pre-Image Resistance}: For a given $y : \Output$, it is infeasible to find $x : \Input$ such that $\hash(x) = y$.
    \item \textbf{Collision Resistance}: It is infeasible to find an $x_1, x_2 : \Input$ such that $x_1 \ne x_2$ and $\hash(x_1) = \hash(x_2)$.
\end{itemize}

\textbf{Notation}: For convenience we refer to $\CRH.\hash(x)$ by $\CRH(x)$.
\end{definition}

\begin{definition}
A \emph{symmetric-key encryption scheme} $\SYM$ is defined by the schema:
\begin{align*}
    \Key &: \Type \\
    \Plaintext &: \Type \\
    \Ciphertext &: \Type \\
    \encrypt &: \Key \times \Plaintext \to \Ciphertext \\
    \decrypt &: \Key \times \Ciphertext \to \Option(\Plaintext)
\end{align*}
with the following properties:

\begin{itemize}
    \item \textbf{Validity}: For all keys $k : \Key$ and plaintexts $p : \Plaintext$, we have that
        \[\decrypt(k, \encrypt(k, p)) = \Some(p)\]
    \item \TODO{hiding, one-time encryption security?}
\end{itemize}
\end{definition}

\begin{definition}
    A \emph{key-agreement scheme} $\KA$ is defined by the schema:
    \begin{align*}
        \PublicKey    &: \Type \\
        \SecretKey    &: \Type \\
        \SharedSecret &: \Type \\
        \derive       &: \SecretKey \to \PublicKey \\
        \agree        &: \SecretKey \times \PublicKey \to \SharedSecret
    \end{align*}
    with the following properties:

    \begin{itemize}
        \item \textbf{Agreement}: For all $\sk_1, \sk_2 : \SecretKey$, $\agree(\sk_1, \derive(\sk_2)) = \agree(\sk_2, \derive(\sk_1))$
        \item \TODO{security properties}
    \end{itemize}
\end{definition}

\begin{definition}
    A \emph{key-derivation function} $\KDF$ defined over a symmetric-key encryption scheme $\SYM$ and a key-agreement scheme $\KA$ is a function of type:
    \[\KDF : \KA.\SharedSecret \to \SYM.\Key\]
\end{definition}

\begin{definition}
    An \emph{integrated encryption scheme} $\IES$ is a hybrid encryption scheme made of up a symmetric-key encryption scheme $\SYM$, a key-agreement scheme $\KA$, and a $\KDF$ to convert from $\KA.\SharedSecret$ to $\SYM.\Key$. We can define the following encryption/decryption algorithms:
    \begin{itemize}
        \item Encryption: Given a secret key $\sk: \KA.\SecretKey$, a public key $\pk: \KA.\PublicKey$, and plaintext $p : \SYM.\Plaintext$, we produce the pair
            \[m := (\KA.\derive(\sk), \SYM.\encrypt(\KDF(\KA.\agree(\sk, \pk)), p)) : \KA.\PublicKey \times \SYM.\Ciphertext\]
        \item Decryption: Given a secret key $\sk : \KA.\SecretKey$, and an encrypted message, as above, $m := (\pk, c) : \KA.\PublicKey \times \SYM.\Ciphertext$, we can decrypt $m$, producing the plaintext,
            \[p := \SYM.\decrypt(\KDF(\KA.\agree(\sk, \pk)), c) : \Option(\SYM.\Plaintext)\]
            which should decrypt successfully if the $\KA.\PublicKey$ that $m$ was encrypted with is the derived key of $\sk : \KA.\SecretKey$.
    \end{itemize}

    \textbf{Notation}: We denote the above \emph{encrypted message} type as $\Message := \KA.\PublicKey \times \SYM.\Ciphertext$, and the above two algorithms by
    \begin{align*}
        \encrypt &: \KA.\SecretKey \times \KA.\PublicKey \times \SYM.\Plaintext \to \Message \\
        \decrypt &: \KA.\SecretKey \times \SYM.\Ciphertext \to \Option(\SYM.\Plaintext)
    \end{align*}
    \TODO{security properties, combine with \SYM{} and \KA{} properties, like the fact that some of these keys should be ephemeral, etc.} \\
    \TODO{add explicit message authentication}
\end{definition}

\begin{definition}
    A \emph{key-diversification scheme} $\KDIV$ over a key-agreement scheme $\KA$ is defined by the schema:
    \begin{align*}
        \public : \KA.\SecretKey \times \KA.\PublicKey \times \KA.\PublicKey \to \KA.\PublicKey \\
        \secret : \KA.\PublicKey \times \KA.\SecretKey \times \KA.\SecretKey \to \KA.\SecretKey
    \end{align*}
    \textbf{Notation}: We refer to the first argument to a $\KDIV$ function as the \emph{diversifier} and we write it as a subscript
    \[\public_d(x, y) := \public(d, x, y) \,\,\text{and}\,\, \secret_d(x, y) := \secret(d, x, y)\]
    For convenience we also write $\KDIV_d$ to mean $\KDIV.\public_d$ or $\KDIV.\secret_d$, when the context is clear.
    
    Every $\KDIV$ also has the following properties:
    \begin{itemize}
        \item \textbf{Derivation Invariance}: For any diversifier $d : \KA.\SecretKey$ and pair of secret keys $(\sk_1, \sk_2)$ we have
            \[\KDIV_d(\KA.\derive(\sk_1), \KA.\derive(\sk_2)) = \KA.\derive(\KDIV_{\KA.\derive(d)}(\sk_1, \sk_2))\]
        \item \TODO{security properties?}
    \end{itemize}
\end{definition}

\begin{definition}
    A \emph{non-interactive zero-knowledge proving system} $\ZKPS$ is defined by the schema:
    \begin{align*}
        \Statement    &: \Type \\
        \ProvingKey   &: \Type \\
        \VerifyingKey &: \Type \\
        \PublicInput  &: \Type \\
        \SecretInput  &: \Type \\
        \Proof        &: \Type \\
        \keys         &: \Statement \to \mathfrak{D}(\ProvingKey \times \VerifyingKey) \\
        \prove        &: \Statement \times \ProvingKey \times \PublicInput \times \SecretInput \to \mathfrak{D}(\Option(\Proof)) \\
        \verify       &: \VerifyingKey \times \PublicInput \times \Proof \to \Bool
    \end{align*}
    \textbf{Notation}: We use the following notation for a $\ZKPS$:
    \begin{itemize}
        \item We write the $\Statement$ and $\ProvingKey$ arguments of $\prove$ in the superscript and subscript respectively,
            \[\prove^P_\pk(x, w) := \prove(P, \pk, x, w)\]
        \item We write the $\VerifyingKey$ argument of $\verify$ in the subscript,
            \[\verify_\vk(x, \pi) := \verify(\vk, x, \pi)\]
        \item We say that $(x, w) : \PublicInput \times \SecretInput$ has the property of being a $\satisfying$ input whenever
            \[\satisfying(x, w) := \exists \pi : \Proof,\, \Some(\pi) \in \prove^P_\pk(x, w)\]
    \end{itemize}

    Every $\ZKPS$ has the following properties for a fixed statement $P : \Statement$ and keys $(\pk, \vk) \sim \keys(P)$:

    \begin{itemize}
        \item \textbf{Completeness}: For all $(x, w) : \PublicInput \times \SecretInput$, if there exists a proof $\pi : \Proof$, such that $\Some(\pi) \in \prove^P_\pk(x, w)$, then $\verify_\vk(x, \pi) = \True$.
        \item \textbf{Knowledge Soundness}: For any polynomial-size adversary $\mathcal{A}$,
            \[\mathcal{A} : \ProvingKey \times \VerifyingKey \to \mathfrak{D}(\PublicInput \times \Proof)\]
             there exists a polynomial-size extractor $\mathcal{E}_\mathcal{A}$
            \[\mathcal{E}_\mathcal{A} : \ProvingKey \times \VerifyingKey \to \mathfrak{D}(\SecretInput)\]
            such that the following probability is negligible:
            \[
                \Prob{
                    \satisfying(x, w) = \False \\
                    \verify_\vk(x, w) = \True
                }{
                    (\pk, \vk) \sim \keys(P) \\
                    (x, \pi) \sim \mathcal{A}(\pk, \vk) \\
                    w \sim \mathcal{E}_\mathcal{A}(\pk, \vk)
                }
            \]
        \item \textbf{Statistical Zero-Knowledge}: There exists a stateful simulator $\mathcal{S}$, such that for all stateful distinguishers $\mathcal{D}$, the difference between the following two probabilities is negligible:
            \[
                \Prob{
                    \satisfying(x, w) = \True \\
                    \mathcal{D}(\pi) = \True
                }{
                    (\pk, \vk) \sim \keys(P) \\
                    (x, w) \sim \mathcal{D}(\pk, \vk) \\
                    \Some(\pi) \sim \prove^P_\pk(x, w)
                }
                \,\,\text{and}\,\,
                \Prob{
                    \satisfying(x, w) = \True \\
                    \mathcal{D}(\pi) = \True
                }{
                    (\pk, \vk) \sim \mathcal{S}(P) \\
                    (x, w) \sim \mathcal{D}(\pk, \vk) \\
                    \pi \sim \mathcal{S}(x)
                }
            \]
        \item \textbf{Succinctness}: For all $(x, w) : \PublicInput \times \SecretInput$, if $\prove(P, \pk, x, w) = \Some(\pi)$, then $\abs{\pi} = \mathcal{O}(1)$, and $\verify(\vk, x, \pi)$ runs in time $\mathcal{O}(\abs{x})$.
    \end{itemize}
\end{definition}

\lsubsection{Addresses and Key Components}{addresses-and-key-components}

Given a choice of $\IES$ for the \Transfer{} protocol we have the following definitions:

\begin{definition}
    A \SpendingKey{} is the following pair of keys:
    \begin{align*}
        \view  &: \IES.\KA.\SecretKey \\
        \spend &: \IES.\KA.\SecretKey
    \end{align*}
    The first secret key is called the \ViewingKey{}.
\end{definition}

\begin{definition}
    A \ReceivingKey{} is the following pair of keys:
    \begin{align*}
        \view  &: \IES.\KA.\PublicKey \\
        \spend &: \IES.\KA.\PublicKey
    \end{align*}
    which is derived from a spending key $\sk : \SpendingKey$ by deriving each component:
    \begin{align*}
        \rk.\view &:= \KA.\derive(\sk.\view) \\
        \rk.\spend   &:= \KA.\derive(\sk.\spend)
    \end{align*}
\end{definition}

\lsubsection{\Transfer{} Protocol}{transfer-protocol}

\begin{definition}
    A \Sender{} is the following tuple:
    \begin{align*}
        \sk       &: \SpendingKey \\
        \tilde{d} &: \IES.\KA.\PublicKey \\
        \trapdoor &: \IES.\KA.\PublicKey \\
        \asset    &: \Asset \\
        \cm       &: \UTXO \\
        \cm_\ROOT &: \MerkleTree.\Root \\
        \cm_\PATH &: \MerkleTree.\Path \\
        \vn       &: \VoidNumber
    \end{align*}

    A \Sender{} is constructed from a spending key $\sk : \SpendingKey$ and an encrypted message $\note : \EncryptedNote$ by the following algorithm:
    \begin{align*}
        S.\sk                       &:= \sk \\
        \tilde{d}, c                &:= \note \\
        \Some(\asset)               &:= \IES.\decrypt(S.\sk.\view, c) \\
        S.\asset                    &:= \asset \\
        S.\tilde{d}                 &:= \tilde{d} \\
        S.\trapdoor                 &:= \KA.\derive(\KDIV_{\tilde{d}}(S.\sk.\view, S.\sk.\spend)) \\
        S.\cm                       &:= \COM_{S.\trapdoor}(S.\asset) \\
        \Some(\cm_\ROOT, \cm_\PATH) &:= \MerkleTree.\contains(S.\cm) \\
        S.\cm_\ROOT                 &:= \cm_\ROOT \\
        S.\cm_\PATH                 &:= \cm_\PATH \\
        S.\vn                       &:= \COM_{S.\tilde{d}}(S.\sk.\view \,||\, S.\sk.\spend) \\
    \end{align*}
\end{definition}

\begin{definition}
    A \SenderPost{} is the following tuple:
    \begin{align*}
        \cm_\ROOT &: \MerkleTree.\Root \\
        \vn       &: \VoidNumber
    \end{align*}
\end{definition}

\begin{definition}
    A \Receiver{} is the following tuple:
    \begin{align*}
        \rk       &: \ReceivingKey \\
        d         &: \IES.\KA.\SecretKey \\
        \trapdoor &: \IES.\KA.\PublicKey \\
        \asset    &: \Asset \\
        \cm       &: \UTXO \\
        \note     &: \EncryptedNote
    \end{align*}
    
    A \Receiver{} is constructed from a receving key $\rk : \ReceivingKey$, an asset $\asset : \Asset$, and a chosen diversifier $d : \IES.\KA.\SecretKey$ by the following algorithm:
    \begin{align*}
        R.\rk       &:= \rk \\
        R.d         &:= d \\
        R.\trapdoor &:= \KDIV_{R.d}(R.\rk.\view, R.\rk.\spend) \\
        R.\asset    &:= \asset \\
        R.\cm       &:= \COM_{R.\trapdoor}(R.\asset) \\
        R.\note     &:= \IES.\encrypt(R.d, R.\rk.\view, \asset)
    \end{align*}
\end{definition}

\begin{definition}
    A \ReceiverPost{} is the following tuple:
    \begin{align*}
        \cm       &: \UTXO \\
        \note     &: \EncryptedNote
    \end{align*}
\end{definition}

\begin{definition}
    A \Transfer{} is a $4$-tuple of finite sets $(T_\source, T_\sender, T_\receiver, T_\sink)$ made up of $\Source$, $\Sender$, $\Receiver$, and $\Sink$ tuples respectively. The \emph{shape} of a \Transfer{} is the $4$-tuple of cardinalities of those sets
    \[\left(\abs{T_\source}, \abs{T_\sender}, \abs{T_\receiver}, \abs{T_\sink}\right)\]
\end{definition}

In order for a \Transfer{} to be considered \emph{valid}, it must adhere to the following constraints:

\begin{itemize}
    \item \textbf{Same Id}: All the \AssetId{s} in the \Transfer{} must be equal.
    \item \textbf{Balanced}: The sum of input \AssetValue{s} must be equal to the sum of output \AssetValue{s}.
    \item \textbf{Well-formed Senders}: All of the \Sender{s} in the \Transfer{} must be constructed according to the above \Sender{} definition.
    \item \textbf{Well-formed Receivers}: All of the \Receiver{s} in the \Transfer{} must be constructed according to the above \Receiver{} definition.
\end{itemize}

In order to prove that these constraints are satisfied for a given \Transfer{}, we build a zero-knowledge proof which will witness that the \Transfer{} is valid and should be accepted by the ledger. It is not necessary to prove that the encryption of $\Receiver.\note$ and the decryption of a $\note$ from the ledger are valid. Deviation from the protocol in encryption or decryption does not reduce the security of the protocol for honest participants.

\begin{definition}(\Transfer{} Validity \Statement{}) A transfer $T : \Transfer$ is considered \emph{valid} if and only if
    \begin{enumerate}
        \item All the \AssetId{s} in $T$ are equal:
            \[
                \abs{
                    \left(\bigcup_{x \in T_\source} x.\asset.\ID \right)
                    \cup
                    \left(\bigcup_{S \in T_\sender} S.\asset.\ID \right)
                    \cup
                    \left(\bigcup_{R \in T_\receiver} R.\asset.\ID \right)
                    \cup
                    \left(\bigcup_{x \in T_\sink} x.\asset.\ID \right)
                } = 1
            \]
        \item The sum of input \AssetValue{s} is equal to the sum of output \AssetValue{s}:
            \[
                \left(\sum_{x \in T_\source} x.\asset.\VALUE\right)
                +
                \left(\sum_{S \in T_\sender} S.\asset.\VALUE\right)
                =
                \left(\sum_{R \in T_\receiver} R.\asset.\VALUE\right)
                +
                \left(\sum_{x \in T_\sink} x.\asset.\VALUE\right)
            \]
        \item For all $S \in T_\sender$, $S$ is well-formed:
            \begin{align*}
                S.\trapdoor                                          &= \KA.\derive(\KDIV_{S.\tilde{d}}(S.\sk.\view, S.\sk.\spend)) \\
                S.\cm                                                &= \COM_{S.\trapdoor}(S.\asset) \\
                S.\vn                                                &= \COM_{S.\tilde{d}}(S.\sk.\view \,||\, S.\sk.\spend) \\
                \MerkleTree.\verify(S.\cm, S.\cm_\ROOT, S.\cm_\PATH) &= \True
            \end{align*}
        \item For all $(i, R) \in \Enumerate(T_\receiver)$ $R$ is well-formed at index $i$ with respect to $\FAIR$:
            \begin{align*}
                R.d         &= \CRH(i \,||\, R.\rk.\view \,||\, R.\rk.\spend \,||\, \FAIR) \\
                R.\trapdoor &= \KDIV_{R.d}(R.\rk.\view, R.\rk.\spend) \\
                R.\cm       &= \COM_{R.\trapdoor}(R.\asset)
            \end{align*}
    \end{enumerate}
    where $\FAIR$ is the following fair randomness constant:
    \[\FAIR := \CRH(\Concat_{S \in T_\sender}(S.\cm))\]
\end{definition}

\TODO{The \VoidNumber{} trapdoor is not a good choice, since the range of possible trapdoor values would be publicly known (the diversifiers in this case are posted to the ledger), so it would remove the hiding property of the commitment.}

\begin{definition}
    A \TransferPost{} is the following tuple:
\end{definition}

\lsection{Concrete Protocol}{concrete-protocol}

\subsection{Constants}

\TODO{add constants for the protocol}

\subsection{Concrete Cryptographic Schemes}

\TODO{add names of cryptographic scheme implementations}

\subsubsection{Commitments}

\subsubsection{Hash Functions}

\subsubsection{Encryption}

\subsubsection{Zero-Knowledge Proving Systems}

\subsubsubsection{Groth16}

\subsubsubsection{PLONK}

\lsection{Differences from $\MantaDAP$}{differences}

\subsection{Reusable Addresses}

\TODO{compare old one-time address protocol to reusable addresses and why reusable is better}

\subsection{\Transfer{} Circuit Unification}

\TODO{compare new single transfer circuit to the many old circuits}

\lsection{Acknowledgements}{acknowledgements}

\TODO{add acknowledgements}

\lsection{References}{references}

\TODO{add references}

\end{document}

