\documentclass[a4paper]{article}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[margin=0.8in]{geometry}
\usepackage[
    colorlinks=true,
    linkcolor=blue,
    filecolor=blue,
    urlcolor=blue,
    pdfpagemode=FullScreen,
]{hyperref}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{commath}
\usepackage{float}
\usepackage{parskip}
\usepackage{tikz-cd}
\usepackage{wrapfig}
\usepackage{hyperref}

\newcommand{\subsubsubsection}[1]{\paragraph{#1}}
\newcommand{\subsubsubsubsection}[1]{\subparagraph{#1}}
\setcounter{secnumdepth}{4}
\setcounter{tocdepth}{4}

\def\sectionautorefname{$\S$}
\def\subsectionautorefname{$\S$}
\def\subsubsectionautorefname{$\S$}
\def\subsubsubsectionautorefname{$\S$}
\def\definitionautorefname{Def}

\newcommand{\lsection}[2]{\def\sectionlabel{#2} \section{#1}\label{sec:#2}}
\newcommand{\lsubsection}[2]{\def\sectionlabel{#2} \subsection{#1}\label{sec:#2}}
\newcommand{\lsubsubsection}[2]{\def\sectionlabel{#2} \subsubsection{#1}\label{sec:#2}}
\newcommand{\lsubsubsubsection}[2]{\def\sectionlabel{#2} \subsubsubsection{#1}\label{sec:#2}}
\newcommand{\lsubsubsubsubsection}[2]{\def\sectionlabel{#2} \subsubsubsubsection{#1}\label{sec:#2}}
\newcommand{\TODO}[1]{{\color{red}\textbf{TODO}}: #1}

\floatstyle{boxed} 
\restylefloat{figure}

\theoremstyle{definition}
\newtheorem{definition}{Definition}[subsection]
\newtheorem*{definition*}{Definition}

\newcommand{\dash}{{\textrm{--}}}
\renewcommand{\abs}[1]{\left|#1\right|}
\newcommand{\Prob}[2]{\mathrm{Pr}\scalebox{0.88}{\ensuremath{\left[\!\!\begin{array}{c}#1\end{array} \middle| \begin{array}{l}#2\end{array}\!\!\right]}}}

\newcommand{\Alice}{{\textsf{Alice}}}
\newcommand{\AssetId}{{\textsf{AssetId}}}
\newcommand{\AssetValue}{{\textsf{AssetValue}}}
\newcommand{\Asset}{{\textsf{Asset}}}
\newcommand{\Bob}{{\textsf{Bob}}}
\newcommand{\Bool}{{\textsf{Bool}}}
\newcommand{\BuildAccumulatorAndZeroes}{{\textsf{BuildAccumulatorAndZeroes}}}
\newcommand{\BuildReceiver}{{\textsf{BuildReceiver}}}
\newcommand{\BuildSenders}{{\textsf{BuildSenders}}}
\newcommand{\COM}{{\textsf{COM}}}
\newcommand{\CRH}{{\textsf{CRH}}}
\newcommand{\Charlie}{{\textsf{Charlie}}}
\newcommand{\CheckProof}{{\textsf{CheckProof}}}
\newcommand{\Checkpoint}{{\textsf{Checkpoint}}}
\newcommand{\Ciphertext}{{\textsf{Ciphertext}}}
\newcommand{\Concat}{{\textsf{Concat}}}
\newcommand{\DCA}{{\textsf{DCA}}}
\newcommand{\Decrypt}{{\textsf{Decrypt}}}
\newcommand{\DerivePublic}{{\textsf{DerivePublic}}}
\newcommand{\Derive}{{\textsf{Derive}}}
\newcommand{\EncryptedNote}{{\textsf{EncryptedNote}}}
\newcommand{\Encrypt}{{\textsf{Encrypt}}}
\newcommand{\EntropySource}{{\textsf{EntropySource}}}
\newcommand{\Enumerate}{{\textsf{enumerate}}}
\newcommand{\FAIR}{{\textsf{FAIR}}}
\newcommand{\False}{{\textsf{False}}}
\newcommand{\FinSet}{{\textsf{FinSet}}}
\newcommand{\GetProof}{{\textsf{GetProof}}}
\newcommand{\HASH}{{\textsf{HASH}}}
\newcommand{\HPKE}{{\textsf{HPKE}}}
\newcommand{\ID}{{\textsf{id}}}
\newcommand{\Input}{{\textsf{Input}}}
\newcommand{\Item}{{\textsf{Item}}}
\newcommand{\KA}{{\textsf{KA}}}
\newcommand{\KDF}{{\textsf{KDF}}}
\newcommand{\KDIV}{{\textsf{KDIV}}}
\newcommand{\KeyDistribution}{{\textsf{KeyDistribution}}}
\newcommand{\Key}{{\textsf{Key}}}
\newcommand{\Ledger}{{\textsf{Ledger}}}
\newcommand{\List}{{\textsf{List}}}
\newcommand{\MantaDAP}{{\Manta{}_{\texttt{DAP}}}}
\newcommand{\MantaPay}{{\textsf{MantaPay}}}
\newcommand{\Manta}{{\textsc{Manta}}}
\newcommand{\MerkleTree}{{\textsf{MerkleTree}}}
\newcommand{\Message}{{\textsf{Message}}}
\newcommand{\Mint}{{\textsf{Mint}}}
\newcommand{\Next}{{\textsf{Next}}}
\newcommand{\None}{{\textsf{None}}}
\newcommand{\NIZK}{{\textsf{NIZK}}}
\newcommand{\Option}{{\textsf{Option}}}
\newcommand{\Output}{{\textsf{Output}}}
\newcommand{\PATH}{{\textsf{path}}}
\newcommand{\PRF}{{\textsf{PRF}}}
\newcommand{\Path}{{\textsf{Path}}}
\newcommand{\Plaintext}{{\textsf{Plaintext}}}
\newcommand{\PrepareZeroes}{{\textsf{PrepareZeroes}}}
\newcommand{\PrivateTransfer}{{\textsf{PrivateTransfer}}}
\newcommand{\Proof}{{\textsf{Proof}}}
\newcommand{\Prop}{{\textsf{Prop}}}
\newcommand{\Prove}{{\textsf{Prove}}}
\newcommand{\ProvingKey}{{\textsf{ProvingKey}}}
\newcommand{\PublicAddress}{{\textsf{PublicAddress}}}
\newcommand{\PublicInput}{{\textsf{PublicInput}}}
\newcommand{\PublicKey}{{\textsf{PublicKey}}}
\newcommand{\PublicLedger}{{\textsf{PublicLedger}}}
\newcommand{\ROOT}{{\textsf{root}}}
\newcommand{\ReceiverPost}{{\textsf{ReceiverPost}}}
\newcommand{\Receiver}{{\textsf{Receiver}}}
\newcommand{\ReceivingKey}{{\textsf{ReceivingKey}}}
\newcommand{\Reclaim}{{\textsf{Reclaim}}}
\newcommand{\Root}{{\textsf{Root}}}
\newcommand{\SYM}{{\textsf{SYM}}}
\newcommand{\Sample}{{\textsf{Sample}}}
\newcommand{\SecretInput}{{\textsf{SecretInput}}}
\newcommand{\SecretKey}{{\textsf{SecretKey}}}
\newcommand{\SeededRng}{{\textsf{SeededRng}}}
\newcommand{\SenderPost}{{\textsf{SenderPost}}}
\newcommand{\Sender}{{\textsf{Sender}}}
\newcommand{\SharedSecret}{{\textsf{SharedSecret}}}
\newcommand{\ShieldedAddress}{{\textsf{ShieldedAddress}}}
\newcommand{\ShieldedAssetPool}{{\textsf{ShieldedAssetPool}}}
\newcommand{\ShieldedIdentity}{{\textsf{ShieldedIdentity}}}
\newcommand{\Sink}{{\textsf{Sink}}}
\newcommand{\Some}{{\textsf{Some}}}
\newcommand{\Source}{{\textsf{Source}}}
\newcommand{\SpendingKey}{{\textsf{SpendingKey}}}
\newcommand{\StateT}{{\textsf{State}}}
\newcommand{\Statement}{{\textsf{Statement}}}
\newcommand{\TransferConfiguration}{{\textsf{TransferConfiguration}}}
\newcommand{\TransferPost}{{\textsf{TransferPost}}}
\newcommand{\Transfer}{{\textsf{Transfer}}}
\newcommand{\TrapdoorDistribution}{{\textsf{TrapdoorDistribution}}}
\newcommand{\Trapdoor}{{\textsf{Trapdoor}}}
\newcommand{\True}{{\textsf{True}}}
\newcommand{\Type}{{\textsf{Type}}}
\newcommand{\UTXOSet}{{\textsf{UTXOSet}}}
\newcommand{\UTXO}{{\textsf{UTXO}}}
\newcommand{\VALUE}{{\textsf{value}}}
\newcommand{\ValidTransfer}{{\textsf{ValidTransfer}}}
\newcommand{\Value}{{\textsf{Value}}}
\newcommand{\VerifyingKey}{{\textsf{VerifyingKey}}}
\newcommand{\Verify}{{\textsf{Verify}}}
\newcommand{\ViewingKey}{{\textsf{ViewingKey}}}
\newcommand{\VoidNumberSet}{{\textsf{VoidNumberSet}}}
\newcommand{\VoidNumber}{{\textsf{VoidNumber}}}
\newcommand{\Void}{{\textsf{Void}}}
\newcommand{\agree}{{\textsf{agree}}}
\newcommand{\allocated}{{\textsf{allocated}}}
\newcommand{\allocate}{{\textsf{allocate}}}
\newcommand{\asset}{{\textsf{asset}}}
\newcommand{\checkpoint}{{\textsf{checkpoint}}}
\newcommand{\cm}{{\textsf{cm}}}
\newcommand{\commit}{{\textsf{commit}}}
\newcommand{\contains}{{\textsf{contains}}}
\newcommand{\decrypt}{{\textsf{decrypt}}}
\newcommand{\derive}{{\textsf{derive}}}
\newcommand{\encrypt}{{\textsf{encrypt}}}
\newcommand{\hash}{{\textsf{hash}}}
\newcommand{\keys}{{\textsf{keys}}}
\newcommand{\len}{{\textsf{len}}}
\newcommand{\mint}{{\textsf{mint}}}
\newcommand{\note}{{\textsf{note}}}
\newcommand{\opk}{{\textsf{opk}}}
\newcommand{\osk}{{\textsf{osk}}}
\newcommand{\pk}{{\textsf{pk}}}
\newcommand{\prove}{{\textsf{prove}}}
\newcommand{\public}{{\textsf{public}}}
\newcommand{\pub}{{\textsf{pub}}}
\newcommand{\receivers}{{\textsf{receivers}}}
\newcommand{\receiver}{{\textsf{receiver}}}
\newcommand{\receive}{{\textsf{receive}}}
\newcommand{\reclaim}{{\textsf{reclaim}}}
\newcommand{\remainder}{{\textsf{remainder}}}
\newcommand{\rk}{{\textsf{rk}}}
\newcommand{\satisfying}{{\textsf{satisfying}}}
\newcommand{\secret}{{\textsf{secret}}}
\newcommand{\senders}{{\textsf{senders}}}
\newcommand{\sender}{{\textsf{sender}}}
\newcommand{\sinks}{{\textsf{sinks}}}
\newcommand{\sink}{{\textsf{sink}}}
\newcommand{\sk}{{\textsf{sk}}}
\newcommand{\sources}{{\textsf{sources}}}
\newcommand{\source}{{\textsf{source}}}
\newcommand{\spend}{{\textsf{spend}}}
\newcommand{\spent}{{\textsf{spent}}}
\newcommand{\stateF}{{\textsf{state}}}
\newcommand{\total}{{\textsf{total}}}
\newcommand{\trapdoor}{{\textsf{trapdoor}}}
\newcommand{\update}{{\textsf{update}}}
\newcommand{\utxos}{{\textsf{utxos}}}
\newcommand{\verify}{{\textsf{verify}}}
\newcommand{\view}{{\textsf{view}}}
\newcommand{\vk}{{\textsf{vk}}}
\newcommand{\vn}{{\textsf{vn}}}

\title{\textbf{\MantaPay{} Protocol Specification}\\ v0.4.0}
\author{Shumo Chu and Brandon H. Gomes}
\date{\today}

\begin{document}
    
\maketitle

\begin{abstract}
    \MantaPay{} is an implementation of a \emph{decentralized anonymous payment} scheme based on the $\MantaDAP$ protocol outlined in the original \href{https://eprint.iacr.org/2021/743.pdf}{\Manta{} whitepaper}.
\end{abstract}
    
\tableofcontents

\lsection{Introduction}{introduction}

\TODO{add introductory remarks}

\lsection{Notation}{notation}

The following notation is used throughout this specification:

\begin{itemize}
    \item $\Type$ is the type of types\footnotemark{}.
    \item If $x : T$ then $x$ is a value and $T$ is a type, denoted $T : \Type$, and we say that $x$ \emph{has type} $T$.
    \item $\Bool$ is the type of booleans with values $\True$ and $\False$.
    \item For any types $A : \Type$ and $B : \Type$ we denote the \emph{type of functions} from $A$ to $B$ as $A \to B : \Type$.
    \item For any types $A : \Type$ and $B : \Type$ we denote the \emph{product type} over $A$ and $B$ as $A \times B : \Type$ with constructor $(\dash, \dash) : A \to (B \to A \times B)$.
    \item For any type $T : \Type$, we define $\Option(T) : \Type$ as the inductive type with constructors:
        \begin{align*}
            \None &: \Option(T) \\
            \Some &: T \to \Option(T)
        \end{align*}
    \item We denote the \emph{type of finite sets} over a type $T : \Type$ as $\FinSet(T) : \Type$. The membership predicate for a value $x : T$ in a finite set $S : \FinSet(T)$ is denoted $x \in S$.
    \item We denote the \emph{type of finite ordered sets} over a type $T : \Type$ as $\List(T) : \Type$. This can either be defined by an inductive type or as a $\FinSet(T)$ with a fixed ordering. We denote the constructor for a list as $[\,\dots\,]$ for an arbitrary set of elements.
    \item We denote the \emph{type of distributions} over a type $T : \Type$ as $\mathfrak{D}(T) : \Type$. A value $x$ sampled from $\mathfrak{D}(T)$ is denoted $x \sim \mathfrak{D}(T)$ and the fact that the value $x$ belongs to the range of $\mathfrak{D}(T)$ is denoted $x \in \mathfrak{D}(T)$. So namely, $y \in \set{x \,|\, x \sim \mathfrak{D}(T)} \leftrightarrow y \in \mathfrak{D}(T)$.
    \item Depending on the context, the notation $\abs{\,\cdot\,}$ denotes either the absolute value of a quantity, the length of a list, the number of characters in a string, or the cardinality of a set.
\end{itemize}

\footnotetext{By \emph{type of types}, we mean the type of \emph{first-level} types in some family of type universes. Discussion of the type theory necessary to make these notions rigorous is beyond the scope of this paper.}

\lsection{Concepts}{concepts}

\subsection{Assets}

The \Asset{} is the fundamental currency object in the \MantaPay{} protocol. An asset $a : \Asset$ is a tuple
\[a = (a.\ID, a.\VALUE) : \AssetId \times \AssetValue\]
where the \AssetId{} encodes the type of currency stored in $a$ and the \AssetValue{} encodes how many units of that currency are stored in $a$.  \MantaPay{} is a \emph{decentralized anonymous payment} protocol which facilitiates the private ownership and private transfer of \Asset{} objects. 

Whenever an \Asset{} is being used in a public setting, we simply refer to it as an \Asset{}, but when the \AssetId{} and/or \AssetValue{} of a particular \Asset{} is meant to be hidden from public view, we refer to the \Asset{} as either, \emph{secret}, \emph{private}, \emph{hidden}, or \emph{shielded}.

\Asset{s} form the basic units of \emph{transactions} which consume \Asset{s} on input, transform them, and return \Asset{s} on output. To preserve the economic value stored in \Asset{s}, the sum of the input \AssetValue{s} must balance the sum of the output \AssetValue{s}, and all assets in a single transaction must have the same \AssetId{}\footnotemark{}. This is called a \emph{balanced transfer}: no \AssetValue{} is created or destroyed in the process. The \MantaPay{} protocol uses a distributed algorithm called \Transfer{} to perform balanced transfers and ensure that they are valid.

\footnotetext{It is beyond the scope of this paper to discuss transactions with inputs and outputs that feature different \AssetId{s}, like those that would be featured in a \emph{decentralized anonymous exchange}.}

\lsubsection{Addresses}{addresses}

In order for \MantaPay{} participants to send and receive \Asset{s} via the \Transfer{} protocol, they create \emph{addresses} which represent their partipation in the protocol. \MantaPay{} has a $3$-address system consisting of a \emph{spending key} $\sk$, a \emph{viewing key} $\vk$, and a \emph{receiving key} $\rk$. The keys have the following uses/properties:

\begin{itemize}
    \item Access to a receiving key $\rk$ represents the ability to send \Asset{s} to the owner of the associated $\sk$.
    \item Access to a viewing key $\vk$ represents the ability to reveal shielded \Asset{} information for \Asset{s} belonging to the owner of the associated $\sk$.
    \item Access to a spending key $\sk$ represents the ability to spend \Asset{s} that were received under the associated receiving key $\rk$.
\end{itemize}

Participants in \MantaPay{} are represented by their addresses, but they are not unique representations, since one participant may have access to more than one triple of keys. See \autoref{sec:addresses-and-key-components} for more information on how these keys are constructed and used for spending, viewing, and receiving \Asset{s}.

\subsection{Ledger}

\begingroup
\setlength{\columnsep}{20pt}

\begin{wrapfigure}{r}[-10pt]{0.5\textwidth}
    \begin{center}
    \begin{tikzcd}
        && \UTXOSet \arrow[ld, "\spend" description, bend right] \\
        \PublicLedger \arrow[r, "\mint"', bend right]
        & \textbf{\Transfer} \arrow[l, "\reclaim"', bend right]
        \arrow[rd, "\spend" description]
        \arrow[ru, "\allocate" description, bend right] & \\
        && \VoidNumberSet
    \end{tikzcd}
    \end{center}
    \caption{Lifecycle of an \Asset{}.}
\end{wrapfigure}

Preserving the economic value of \Asset{s} requires more than just balanced transfers. It also requires that \Asset{s} are owned by exactly one address at a time, namely, that the ability to spend an \Asset{} can be proved before a transfer and revoked after a transfer. It is not simply the \emph{information-content} of an \Asset{} that should be transfered, but the \emph{ability to spend the asset in the future}, which should be transfered. To enforce this second invariant we can use a public ledger\footnotemark{} that keeps track of the movement of \Asset{s} from one participant to another. Unfortunately, using a public ledger alone does not allow participants to remain anonymous, so \MantaPay{} extends the public ledger by adding a special account called the \emph{shielded asset pool} which is responsible for keeping track of the \Asset{s} which have been anonymized by the protocol. We denote the three ledger types in the protocol as follows: the public ledger as \PublicLedger{}, the shielded asset pool as \ShieldedAssetPool{}, and the combined ledger we denote \Ledger{}.

The \ShieldedAssetPool{} is made up of four parts which serve to enforce the balanced transfer of \Asset{s} among anonymous participants:

\begin{enumerate}
    \item \ShieldedAssetPool{} Balance: The \Ledger{} contains a collection of \Asset{s} which encode the combined economic value of the \ShieldedAssetPool{} and the \PublicLedger{}. The \ShieldedAssetPool{} balance is the subset of this total collection that has been anonymized by the \MantaPay{} protocol. This balance is stored as a finite set of non-zero \Asset{s}.
    \item \autoref{sec:ledger-utxo-set} \UTXOSet{}: The \UTXOSet{} is a collection of ownership claims to subsets of the \ShieldedAssetPool{} (called \UTXO{s}), each one refering to an allocated \Asset{} transfered to a participant of the protocol.
    \item \autoref{sec:ledger-encrypted-notes} \EncryptedNote{s}: For every \UTXO{} there is a matching \EncryptedNote{} which contains information necessary to spend the \Asset{}, which can be used to \emph{provably reconstruct} the \UTXO{} convincing the \Ledger{} of unique ownership. The \EncryptedNote{} can only be decrypted by the recipient of the \Asset{}, specifically, the correct viewing key $\vk$. See \autoref{sec:addresses} for more.
    \item \autoref{sec:ledger-void-number-set} \VoidNumberSet{}: The \VoidNumberSet{} is a collection of commitments, like \UTXO{s}, but which track the \emph{spent state} of an \Asset{} and are used to prove to the \Ledger{} that an \Asset{} is spent \emph{exactly one time}. 
\end{enumerate}

The operation of these different parts of the \ShieldedAssetPool{} is elaborated in the following subsections.

\endgroup

\footnotetext{A public (or private) ledger is not enough to solve the \emph{provable-ownership problem} or the \emph{double-spending problem}. A \emph{consensus mechanism} is also required to ensure that all participants agree on the current state of the ledger. The design and specification of the consensus mechanism that secures the \MantaPay{} ledger is beyond the scope of this paper.}

\lsubsubsection{\UTXO{s} and the \UTXOSet{}}{ledger-utxo-set}

An \emph{unspent transaction output}, or \UTXO{} for short, represents a claim to the output of a balanced transfer which has otherwise \emph{not yet been spent}. Every balanced transfer produces \emph{public outputs}, just publicly visible \Asset{s}, and \emph{private outputs}, represented by \UTXO{s}, and these \UTXO{s} are stored in the \UTXOSet{} of the \ShieldedAssetPool{}. A \UTXO{} can only be claimed by the participant who owns the underlying \Asset{}, where ownership means \emph{knowledge of the correct spending key} and the \Transfer{} protocol requires that all inputs to a balanced transfer \emph{prove} that they own a \UTXO{} which the \ShieldedAssetPool{} has already seen in the past. The \UTXOSet{} is \emph{append-only} since it represents the past state of \emph{unspent} \Asset{s}. \UTXO{s} can only be added to the \UTXOSet{} as outputs in the execution of a \Transfer{} which the \Ledger{} checks for correctness.

\lsubsubsection{\EncryptedNote{s}}{ledger-encrypted-notes}

In order to find out what \Asset{} a \UTXO{} is connected to, every \UTXO{} comes with an associated \EncryptedNote{} which stores two pieces of information, the underlying \Asset{}, and a key diversifier, a value which allows the new owner of the \Asset{} to reconstruct the \UTXO{}. Being able to \emph{provably reconstruct} a correct \UTXO{} is a prerequisite to ownership and the ability to spend the \Asset{} in the future. Once a participant spends an \Asset{} that they can decrypt, they build a new \EncryptedNote{} for the next participant that they sent their \Asset{s} to, so that they can then spend it, and so on. This is called the \emph{in-band secret distribution}.

\lsubsubsection{\VoidNumber{s} and the \VoidNumberSet{}}{ledger-void-number-set}

Once the ability to spend an \Asset{} is extracted from a $(\UTXO, \EncryptedNote)$ pair, the \ShieldedAssetPool{} requires another commitment in order to spend the \Asset{}, transfering it to another participant. This commitment, called the \VoidNumber{}, represents the revocation of the right to spend the \Asset{} in the future, and ensures that the same \Asset{} cannot be spent twice. Like the \UTXOSet{}, the \VoidNumberSet{} is \emph{append-only} since it represents the past state of \emph{spent} \Asset{s}. \VoidNumber{s} can only be added to the \VoidNumberSet{} as inputs in the execution of a \Transfer{} which the \Ledger{} checks for correctness.

\lsection{Abstract Protocol}{abstract-protocol}

\subsection{Abstract Cryptographic Schemes}

In the following section, we outline the formal specifications for all of the \emph{cryptographic schemes} used in the \MantaPay{} protocol.

\begin{definition}[Commitment Scheme]
    A \emph{commitment scheme} $\COM$ is defined by the schema:
    \begin{align*}
        \Trapdoor             &: \Type \\
        \Input                &: \Type \\
        \Output               &: \Type \\
        \TrapdoorDistribution &: \mathfrak{D}(\Trapdoor) \\
        \commit               &: \Trapdoor \times \Input \to \Output
    \end{align*}
    with the following properties:
    \begin{itemize}
        \item \textbf{Binding}: It is infeasible to find an $x, y : \Input$ and $r, s: \Trapdoor$ such that $x \ne y$ and $\commit(r,x) = \commit(s,y)$.
        \item \textbf{Hiding}: For all $x, y : \Input$, the distributions $\set{\commit(r,x) \,|\, r \sim \TrapdoorDistribution}$ and \\ $\set{\commit(r,y) \,|\, r \sim \TrapdoorDistribution}$ are \emph{computationally indistinguishable}.
    \end{itemize}

    \textbf{Notation}: For convenience, we refer to $\COM.\commit(r,x)$ by $\COM_r(x)$.
\end{definition}

\begin{definition}[Hash Function]
    A \emph{hash function} $\CRH$ is defined by the schema:
    \begin{align*}
        \Input  &: \Type \\
        \Output &: \Type \\
        \hash   &: \Input \to \Output
    \end{align*}
    with the following properties:
    \begin{itemize}
        \item \textbf{Pre-Image Resistance}: For a given $y : \Output$, it is infeasible to find $x : \Input$ such that $\hash(x) = y$.
        \item \textbf{Collision Resistance}: It is infeasible to find an $x_1, x_2 : \Input$ such that $x_1 \ne x_2$ and $\hash(x_1) = \hash(x_2)$.
    \end{itemize}

    \textbf{Notation}: For convenience, we refer to $\CRH.\hash(x)$ by $\CRH(x)$.
\end{definition}

\begin{definition}[Symmetric-Key Encryption Scheme]
    A \emph{symmetric-key encryption scheme} $\SYM$ is defined by the schema:
    \begin{align*}
        \Key &: \Type \\
        \Plaintext &: \Type \\
        \Ciphertext &: \Type \\
        \encrypt &: \Key \times \Plaintext \to \Ciphertext \\
        \decrypt &: \Key \times \Ciphertext \to \Option(\Plaintext)
    \end{align*}
    with the following properties:
    \begin{itemize}
        \item \textbf{Validity}: For all keys $k : \Key$ and plaintexts $p : \Plaintext$, we have that
            \[\decrypt(k, \encrypt(k, p)) = \Some(p)\]
        \item \TODO{hiding, one-time encryption security?}
    \end{itemize}
\end{definition}

\begin{definition}[Key-Agreement Scheme]
    A \emph{key-agreement scheme} $\KA$ is defined by the schema:
    \begin{align*}
        \PublicKey    &: \Type \\
        \SecretKey    &: \Type \\
        \SharedSecret &: \Type \\
        \derive       &: \SecretKey \to \PublicKey \\
        \agree        &: \SecretKey \times \PublicKey \to \SharedSecret
    \end{align*}
    with the following properties:
    \begin{itemize}
        \item \textbf{Agreement}: For all $\sk_1, \sk_2 : \SecretKey$, $\agree(\sk_1, \derive(\sk_2)) = \agree(\sk_2, \derive(\sk_1))$
        \item \TODO{security properties}
    \end{itemize}
\end{definition}

\begin{definition}[Key-Diversification Scheme]
    A \emph{key-diversification scheme} $\KDIV$ over a key-agreement scheme $\KA$ is defined by the schema:
    \begin{align*}
        \public : \KA.\SecretKey \times \KA.\PublicKey \times \KA.\PublicKey \to \KA.\PublicKey \\
        \secret : \KA.\PublicKey \times \KA.\SecretKey \times \KA.\SecretKey \to \KA.\SecretKey
    \end{align*}
    \textbf{Notation}: We refer to the first argument to a $\KDIV$ function as the \emph{diversifier} and we write it as a subscript
    \[\public_d(x, y) := \public(d, x, y) \,\,\text{and}\,\, \secret_d(x, y) := \secret(d, x, y)\]
    For convenience, we also write $\KDIV_d$ to mean $\KDIV.\public_d$ or $\KDIV.\secret_d$, when the context is clear.
    
    Every $\KDIV$ also has the following properties:
    \begin{itemize}
        \item \textbf{Derivation Invariance}: For any diversifier $d : \KA.\SecretKey$ and pair of secret keys $(\sk_1, \sk_2)$ we have
            \[\KDIV_d(\KA.\derive(\sk_1), \KA.\derive(\sk_2)) = \KA.\derive(\KDIV_{\KA.\derive(d)}(\sk_1, \sk_2))\]
        \item \TODO{security properties?}
    \end{itemize}
\end{definition}

\begin{definition}[Key-Derivation Function]
    A \emph{key-derivation function} $\KDF$ defined over a symmetric-key encryption scheme $\SYM$ and a key-agreement scheme $\KA$ is a function of type:
    \[\KDF : \KA.\SharedSecret \to \SYM.\Key\]
    with the following properties:
    \begin{itemize}
        \item \TODO{security properties}
    \end{itemize}
\end{definition}

\begin{definition}[Hybrid Public Key Encryption]
    An \emph{hybrid public key encryption scheme} \cite{irtf-cfrg-hpke-12} $\HPKE$ is a hybrid encryption scheme made of up a symmetric-key encryption scheme $\SYM$, a key-agreement scheme $\KA$, and a key-derivation function $\KDF$ to convert from $\KA.\SharedSecret$ to $\SYM.\Key$. We can define the following encryption/decryption algorithms:
    \begin{itemize}
        \item Encryption: Given a secret key $\sk: \KA.\SecretKey$, a public key $\pk: \KA.\PublicKey$, and plaintext $p : \SYM.\Plaintext$, we produce the pair
            \[m : \KA.\PublicKey \times \SYM.\Ciphertext := \left(\KA.\derive(\sk), \SYM.\encrypt(\KDF(\KA.\agree(\sk, \pk)), p)\right)\]
        \item Decryption: Given a secret key $\sk : \KA.\SecretKey$, and an encrypted message, as above, $m := (\pk, c)$, we can decrypt $m$, producing the plaintext,
            \[p : \Option(\SYM.\Plaintext) := \SYM.\decrypt(\KDF(\KA.\agree(\sk, \pk)), c)\]
            which should decrypt successfully if the $\KA.\PublicKey$ that $m$ was encrypted with is the derived key of $\sk : \KA.\SecretKey$.
    \end{itemize}

    \textbf{Notation}: We denote the above \emph{encrypted message} type as $\Message := \KA.\PublicKey \times \SYM.\Ciphertext$, and the above two algorithms by
    \begin{align*}
        \encrypt &: \KA.\SecretKey \times \KA.\PublicKey \times \SYM.\Plaintext \to \Message \\
        \decrypt &: \KA.\SecretKey \times \KA.\PublicKey \times \SYM.\Ciphertext \to \Option(\SYM.\Plaintext)
    \end{align*}
    \TODO{security properties, combine with \SYM{} and \KA{} properties, like the fact that some of these keys should be ephemeral, etc.} \\
\end{definition}

\begin{definition}[Dynamic Cryptographic Accumulator]
    A \emph{dynamic cryptographic accumulator} $\DCA$ is defined by the schema:
    \begin{align*}
        \Item       &: \Type \\
        \StateT     &: \Type \\
        \Checkpoint &: \Type \\
        \Proof      &: \Type \\
        \checkpoint &: \StateT \to \Checkpoint \\
        \update     &: \Item \times \StateT \to \StateT \\
        \contains   &: \Item \times \StateT \to \Option(\Checkpoint \times \Proof) \\
        \verify     &: \Item \times \Checkpoint \times \Proof \to \Bool
    \end{align*}
    with the following properties:
    \begin{itemize}
        \item \textbf{Unique Checkpoints}: For any initial state $s : \StateT$ and any list of items $I : \List(\Item)$ we can generate the sequence of states:
            \[s_0 := s, \,\,\,\,\, s_{i + 1} := \update(I_i, s_i)\]
            Then, if we collect the checkpoints for these states, $c_i := \checkpoint(s_i)$, there should be exactly $\abs{I}$-many unique checkpoints, one for each state update.
        \item \textbf{Provable Membership}: For any initial state $s : \StateT$ and any list of items $I : \List(\Item)$ we can generate the sequences of states:
            \[s_0 := s, \,\,\,\,\, s_{i + 1} := \update(I_i, s_i)\]
            Then, if we collect the states $s_i$ into a set $S$, we have the following property for all $s \in S$ and $t \in I$,
            \[\Some(c, \pi) := \contains(t, s), \,\,\,\,\, \verify(t, c, \pi) = \True\]
        \item \TODO{security properties}
    \end{itemize}
    \TODO{add finite capacity constraint, something like $\update : \Item \times \StateT \to \Option(\StateT)$ where it fails when capacity is reached}
\end{definition}

\begin{definition}[Non-Interactive Zero-Knowledge Proving System]
    A \emph{non-interactive zero-knowledge proving system} $\NIZK$ is defined by the schema:
    \begin{align*}
        \Statement    &: \Type \\
        \ProvingKey   &: \Type \\
        \VerifyingKey &: \Type \\
        \PublicInput  &: \Type \\
        \SecretInput  &: \Type \\
        \Proof        &: \Type \\
        \keys         &: \Statement \to \mathfrak{D}(\ProvingKey \times \VerifyingKey) \\
        \prove        &: \Statement \times \ProvingKey \times \PublicInput \times \SecretInput \to \mathfrak{D}(\Option(\Proof)) \\
        \verify       &: \VerifyingKey \times \PublicInput \times \Proof \to \Bool
    \end{align*}
    \textbf{Notation}: We use the following notation for a $\NIZK$:
    \begin{itemize}
        \item We write the $\Statement$ and $\ProvingKey$ arguments of $\prove$ in the superscript and subscript respectively,
            \[\prove^P_\pk(x, w) := \prove(P, \pk, x, w)\]
        \item We write the $\VerifyingKey$ argument of $\verify$ in the subscript,
            \[\verify_\vk(x, \pi) := \verify(\vk, x, \pi)\]
        \item We say that $(x, w) : \PublicInput \times \SecretInput$ has the property of being a $\satisfying$ input whenever
            \[\satisfying^P_\pk(x, w) := \exists \pi : \Proof,\, \Some(\pi) \in \prove^P_\pk(x, w)\]
    \end{itemize}

    Every $\NIZK$ has the following properties for a fixed statement $P : \Statement$ and keys $(\pk, \vk) \sim \keys(P)$:

    \begin{itemize}
        \item \textbf{Completeness}: For all $(x, w) : \PublicInput \times \SecretInput$, if $\satisfying^P_\pk(x, w) = \True$ with proof witness $\pi$, then $\verify_\vk(x, \pi) = \True$.
        \item \textbf{Knowledge Soundness}: For any polynomial-size adversary $\mathcal{A}$,
            \[\mathcal{A} : \ProvingKey \times \VerifyingKey \to \mathfrak{D}(\PublicInput \times \Proof)\]
             there exists a polynomial-size extractor $\mathcal{E}_\mathcal{A}$
            \[\mathcal{E}_\mathcal{A} : \ProvingKey \times \VerifyingKey \to \mathfrak{D}(\SecretInput)\]
            such that the following probability is negligible:
            \[
                \Prob{
                    \satisfying^P_\pk(x, w) = \False \\
                    \verify_\vk(x, w) = \True
                }{
                    (\pk, \vk) \sim \keys(P) \\
                    (x, \pi) \sim \mathcal{A}(\pk, \vk) \\
                    w \sim \mathcal{E}_\mathcal{A}(\pk, \vk)
                }
            \]
        \item \textbf{Statistical Zero-Knowledge}: There exists a stateful simulator $\mathcal{S}$, such that for all stateful distinguishers $\mathcal{D}$, the difference between the following two probabilities is negligible:
            \[
                \Prob{
                    \satisfying^P_\pk(x, w) = \True \\
                    \mathcal{D}(\pi) = \True
                }{
                    (\pk, \vk) \sim \keys(P) \\
                    (x, w) \sim \mathcal{D}(\pk, \vk) \\
                    \Some(\pi) \sim \prove^P_\pk(x, w)
                }
                \,\,\text{and}\,\,
                \Prob{
                    \satisfying^P_\pk(x, w) = \True \\
                    \mathcal{D}(\pi) = \True
                }{
                    (\pk, \vk) \sim \mathcal{S}(P) \\
                    (x, w) \sim \mathcal{D}(\pk, \vk) \\
                    \pi \sim \mathcal{S}(x)
                }
            \]
        \item \textbf{Succinctness}: For all $(x, w) : \PublicInput \times \SecretInput$, if $\Some(\pi) \sim \prove(P, \pk, x, w)$, then $\abs{\pi} = \mathcal{O}(1)$, and $\verify(\vk, x, \pi)$ runs in time $\mathcal{O}(\abs{x})$.
    \end{itemize}
\end{definition}

\lsubsection{Addresses and Key Components}{addresses-and-key-components}

Given a choice of $\HPKE$ we have the following definitions:

\begin{definition}[Spending Key]
    A \SpendingKey{} is the following pair of keys:
    \begin{align*}
        \view  &: \HPKE.\KA.\SecretKey \\
        \spend &: \HPKE.\KA.\SecretKey
    \end{align*}
    The first secret key, $\view$, is called the \ViewingKey{}.
\end{definition}

\begin{definition}[Receiving Key]
    A \ReceivingKey{} is the following pair of keys:
    \begin{align*}
        \view  &: \HPKE.\KA.\PublicKey \\
        \spend &: \HPKE.\KA.\PublicKey
    \end{align*}
    which is derived from a spending key $\sk : \SpendingKey$ by deriving each component:
    \begin{align*}
        \rk.\view  &:= \KA.\derive(\sk.\view) \\
        \rk.\spend &:= \KA.\derive(\sk.\spend)
    \end{align*}
\end{definition}

A keypair $(\sk, \rk) : \SpendingKey \times \ReceivingKey$, represents the ability to spend and receive \Asset{s} as a unique \emph{representative participant} on the \Ledger. Any user of the \MantaPay{} protocol can create many such keypairs, but each one represents a different participant and \Asset{s} must be transfered between them using the \Transfer{} protocol as if they were independently owned by different users. A \ReceivingKey{} can be used to receive any number of \Asset{s} and the \SpendingKey{} can be used to spend any number of those \Asset{s}. See \autoref{sec:abstract-semantic-transactions} for the protocol used to spend a subset of \Asset{s} owned by a single user.

\textbf{Important}: To every spending key $\sk : \SpendingKey$ we have an assoicated viewing key $\vk : \ViewingKey := \sk.\view$ which allows the owner to decrypt the encrypted messages associated to $\sk$, but does not contain enough information to perform a spend with those \Asset{s}. This can be used for account auditing purposes, and for removing anonymity, but sharing this key should be done with caution.

\lsubsection{\Transfer{} Protocol}{transfer-protocol}

The \Transfer{} protocol is the fundamental abstraction in \MantaPay{} and facilitiates the valid transfer of \Asset{s} among participants while preserving their anonymity. The \Transfer{} is made up of special cryptographic constructions called \Sender{s} and \Receiver{s} which represent the private input and the private output of a transaction. To perform a \Transfer{}, a protocol participant gathers the \SpendingKey{s} they own, selects a subset of the \UTXO{s} they have still not spent (with a fixed \AssetId{}), collects \ReceivingKey{s} from other participants for the outputs, assigning each key a subset of the input \Asset{s}, and then builds a \Transfer{} object representing the transfer they want to build. From this \Transfer{} object, they construct a \TransferPost{} which they then send to the \Ledger{} to be validated and stored, representing a completed state transition in the \Ledger{}. The transformation from \Transfer{} to \TransferPost{} involves keeping the parts of the \Transfer{} that \emph{must} be known to the \Ledger{} and for the parts that \emph{must} not be known, substituting them for a \emph{zero-knowledge proof} representing the validity of the secret information known to the participant, and the \Transfer{} as a whole.

We begin by defining the cryptographic primitives involved in the \Transfer{} protocol:

\begin{definition}[Transfer Configuration]
    A \TransferConfiguration{} is a collection of implementations of the following abstract cryptographic primitives:
    \begin{itemize}
        \item \textbf{Hybrid Public Key Encryption}: $\HPKE$
        \item \textbf{Commitment Scheme}: $\COM$
        \item \textbf{Hash Function}: $\CRH$
        \item \textbf{Dynamic Cryptographic Accumulator}: $\DCA$
        \item \textbf{Zero-Knowledge Proving System}: $\NIZK$
    \end{itemize}
    with the following notational conventions:
    \begin{align*}
        \KA            &:= \HPKE.\KA \\
        \KDIV          &:= \HPKE.\KDIV \\
        \UTXO          &:= \COM.\Output \\
        \VoidNumber    &:= \COM.\Output \\
        \EncryptedNote &:= \HPKE.\Message \\
        \UTXOSet       &:= \DCA
    \end{align*}
    and the following constraints:
    \begin{align*}
        \COM.\Trapdoor &= \KA.\PublicKey \\
        \ValidTransfer &: \NIZK.\Statement
    \end{align*}
    where \ValidTransfer{} is defined below.

    \TODO{Add the fact that $\COM.\Input$ has a concatenation property. In general, add (de)serialization to the spec.} \\
    \TODO{Add the fact that we have a conversion from $\CRH.\Output$ to $\KA.\SecretKey$, notably for diversifiers, i.e. serialize the output and then deserialize into a secret key (need to match the size)}
\end{definition}

For the rest of this section, we assume the existence of a \TransferConfiguration{} and use the primitives outlines above explicitly. We continue by defining the \Sender{} and \Receiver{} constructions as well as their public counterparts, the \SenderPost{} and \ReceiverPost{}.

\begin{definition}[\Transfer{} Sender]
    A \Sender{} is the following tuple:
    \begin{align*}
        \sk       &: \SpendingKey \\
        \tilde{d} &: \KA.\PublicKey \\
        \trapdoor &: \KA.\PublicKey \\
        \asset    &: \Asset \\
        \cm       &: \UTXO \\
        \cm_c     &: \UTXOSet.\Checkpoint \\
        \cm_\pi   &: \UTXOSet.\Proof \\
        \vn       &: \VoidNumber
    \end{align*}

    A \Sender{}, $S$, is constructed from a spending key $\sk : \SpendingKey$ and an encrypted message $\note : \EncryptedNote$ with the following algorithm:
    \begin{align*}
        S.\sk                 &:= \sk \\
        \tilde{d}, c          &:= \note \\
        \Some(\asset)         &:= \HPKE.\decrypt(S.\sk.\view, \tilde{d}, c) \\
        S.\asset              &:= \asset \\
        S.\tilde{d}           &:= \tilde{d} \\
        S.\trapdoor           &:= \KA.\derive(\KDIV_{S.\tilde{d}}(S.\sk.\view, S.\sk.\spend)) \\
        S.\cm                 &:= \COM_{S.\trapdoor}(S.\asset) \\
        \Some(\cm_c, \cm_\pi) &:= \UTXOSet.\contains(S.\cm, \Ledger.\utxos()) \\
        S.\cm_c               &:= \cm_c \\
        S.\cm_\pi             &:= \cm_\pi \\
        S.\vn                 &:= \COM_{S.\tilde{d}}(S.\sk.\view \,||\, S.\sk.\spend) \\
    \end{align*}
\end{definition}

\begin{definition}[\Transfer{} Sender Post]
    A \SenderPost{} is the following tuple extracted from a \Sender{}:
    \begin{align*}
        \cm_c &: \UTXOSet.\Checkpoint \\
        \vn   &: \VoidNumber
    \end{align*}
    which are the parts of a \Sender{} which should be \emph{posted} to the \Ledger{}.
\end{definition}

\begin{definition}[\Transfer{} Receiver]
    A \Receiver{} is the following tuple:
    \begin{align*}
        \rk       &: \ReceivingKey \\
        d         &: \KA.\SecretKey \\
        \trapdoor &: \KA.\PublicKey \\
        \asset    &: \Asset \\
        \cm       &: \UTXO \\
        \note     &: \EncryptedNote
    \end{align*}
    
    A \Receiver{}, $R$, is constructed from a receving key $\rk : \ReceivingKey$, an asset $\asset : \Asset$, and a given\footnotemark{} diversifier $d : \HPKE.\KA.\SecretKey$ with the following algorithm:
    \begin{align*}
        R.\rk       &:= \rk \\
        R.d         &:= d \\
        R.\trapdoor &:= \KDIV_{R.d}(R.\rk.\view, R.\rk.\spend) \\
        R.\asset    &:= \asset \\
        R.\cm       &:= \COM_{R.\trapdoor}(R.\asset) \\
        R.\note     &:= \HPKE.\encrypt(R.d, R.\rk.\view, \asset)
    \end{align*}
\end{definition}

\footnotetext{The key-diversifier is not chosen by the ledger participants building the \Transfer{}. Instead, it is derived from other \Transfer{} data and the current state of the ledger. See \autoref{def:transfer-validity-statement} for more.}

\begin{definition}[\Transfer{} Receiver Post]
    A \ReceiverPost{} is the following tuple extracted from a \Receiver{}:
    \begin{align*}
        \cm       &: \UTXO \\
        \note     &: \EncryptedNote
    \end{align*}
    which are the parts of a \Receiver{} which should be \emph{posted} to the \Ledger{}.
\end{definition}

\begin{definition}[\Transfer{} Sources and Sinks]
    A \Source{} (or a \Sink{}) is an \Asset{} representing a public input (or output) of a \Transfer{}.
\end{definition}

\begin{definition}[\Transfer{} Object]
    A \Transfer{} is the following tuple:
    \begin{align*}
        \sources    &: \List(\Asset) \\
        \senders    &: \List(\Sender) \\
        \receivers  &: \List(\Receiver) \\
        \sinks      &: \List(\Asset)
    \end{align*}
    The \emph{shape} of a \Transfer{} is the following $4$-tuple of cardinalities of those sets
    \[\left(\abs{T.\sources}, \abs{T.\senders}, \abs{T.\receivers}, \abs{T.\sinks}\right)\]
\end{definition}

In order for a \Transfer{} to be considered \emph{valid}, it must adhere to the following constraints:

\begin{itemize}
    \item \textbf{Same Id}: All the \AssetId{s} in the \Transfer{} must be equal.
    \item \textbf{Balanced}: The sum of input \AssetValue{s} must be equal to the sum of output \AssetValue{s}.
    \item \textbf{Well-formed Senders}: All of the \Sender{s} in the \Transfer{} must be constructed according to the above \Sender{} definition.
    \item \textbf{Well-formed Receivers}: All of the \Receiver{s} in the \Transfer{} must be constructed according to the above \Receiver{} definition.
\end{itemize}

In order to prove that these constraints are satisfied for a given \Transfer{}, we build a zero-knowledge proof which will witness that the \Transfer{} is valid and should be accepted by the \Ledger{}. It is not necessary to prove that the encryption of $\Receiver.\note$ and the decryption of a $\note$ from the \Ledger{} are valid. Deviation from the protocol in encryption or decryption stages does not reduce the security of the protocol for honest participants.

\begin{definition}[\Transfer{} Validity \Statement{}]\label{def:transfer-validity-statement}
    A transfer $T : \Transfer$ is considered \emph{valid} if and only if
    \begin{enumerate}
        \item All the \AssetId{s} in $T$ are equal:
            \[
                \abs{
                    \left(\bigcup_{a \in T.\sources} a.\ID \right)
                    \cup
                    \left(\bigcup_{S \in T.\senders} S.\asset.\ID \right)
                    \cup
                    \left(\bigcup_{R \in T.\receivers} R.\asset.\ID \right)
                    \cup
                    \left(\bigcup_{a \in T.\sinks} a.\ID \right)
                } = 1
            \]
        \item The sum of input \AssetValue{s} is equal to the sum of output \AssetValue{s}:
            \[
                \left(\sum_{a \in T.\sources} a.\VALUE\right)
                +
                \left(\sum_{S \in T.\senders} S.\asset.\VALUE\right)
                =
                \left(\sum_{R \in T.\receivers} R.\asset.\VALUE\right)
                +
                \left(\sum_{a \in T.\sinks} a.\VALUE\right)
            \]
        \item For all $S \in T.\senders$, the \Sender{} $S$ is well-formed:
            \begin{align*}
                S.\trapdoor                                 &= \KA.\derive(\KDIV_{S.\tilde{d}}(S.\sk.\view, S.\sk.\spend)) \\
                S.\cm                                       &= \COM_{S.\trapdoor}(S.\asset) \\
                S.\vn                                       &= \COM_{S.\tilde{d}}(S.\sk.\view \,||\, S.\sk.\spend) \\
                \UTXOSet.\verify(S.\cm, S.\cm_c, S.\cm_\pi) &= \True
            \end{align*}
        \item For all $(i, R) \in \Enumerate(T.\receivers)$, the \Receiver{} $R$ is well-formed at index $i$ with respect to \FAIR{}:
            \begin{align*}
                R.d         &= \CRH(i \,||\, R.\rk.\view \,||\, R.\rk.\spend \,||\, \FAIR) \\
                R.\trapdoor &= \KDIV_{R.d}(R.\rk.\view, R.\rk.\spend) \\
                R.\cm       &= \COM_{R.\trapdoor}(R.\asset)
            \end{align*}
            where \FAIR{} is the following constant, using the ledger as a randomness oracle:
            \[\FAIR := \CRH(\UTXOSet.\checkpoint(\Ledger.\utxos()) \,||\, \Concat_{S \in T.\senders}(S.\sk.\spend))\]
    \end{enumerate}
    \textbf{Notation}: This statement is denoted $\ValidTransfer$ and is assumed to be expressible as a \Statement{} of \NIZK{}.
\end{definition}

\begin{definition}[\Transfer{} Post]
    A \TransferPost{} is the following tuple:
    \begin{align*}
        \sources   &: \List(\Source) \\
        \senders   &: \List(\SenderPost) \\
        \receivers &: \List(\ReceiverPost) \\
        \sinks     &: \List(\Sink) \\
        \pi        &: \NIZK.\Proof
    \end{align*}
    A \TransferPost{}, $P$, is constructed by assembling the zero-knowledge proof of \Transfer{} validity from a known proving key $\pk : \NIZK.\ProvingKey$ and a given $T : \Transfer$:
    \begin{align*}
        x            &:= \Transfer.\public(T) \\
        w            &:= \Transfer.\secret(T) \\
        \Some(\pi)   &\sim \NIZK.\prove^\ValidTransfer_\pk(x, w) \\
        P.\sources   &:= x.\sources \\
        P.\senders   &:= x.\senders \\
        P.\receivers &:= x.\receivers \\
        P.\sinks     &:= x.\sinks \\
        P.\pi        &:= \pi
    \end{align*}
    where $\Transfer.\public$ returns \SenderPost{s} for each \Sender{} in $T$ and \ReceiverPost{s} for each \Receiver{} in $T$, keeping \Source{s} and \Sink{s} as they are, and $\Transfer.\secret$ returns all the rest of $T$ which is not part of the output of $\Transfer.\public$.
\end{definition}

Now that a participant has constructed a transfer post $P : \TransferPost$ they can send it to the \Ledger{} for verification. 

\begin{definition}[\Ledger{}-side \Transfer{} Validity]
    To check that $P$ represents a valid \Transfer{}, the ledger checks the following:
    \begin{itemize}
        \item \textbf{Public Withdraw}: All the public addresses corresponding to the \Asset{s} in $P.\sources$ have enough public balance (i.e. in the \PublicLedger{}) to withdraw the given \Asset{}.
        \item \textbf{Public Deposit}: All the public addresses corresponding to the \Asset{s} in $P.\sinks$ exist.
        \item \textbf{Shielded Withdraw}: The total balance in $P.\sinks$ does not exceed the amount in the $\ShieldedAssetPool{}$ balance.
        \item \textbf{Current \Checkpoint{}}: The $\UTXOSet.\Checkpoint$ stored in each $P.\senders$ is equal to current checkpoint, $\UTXOSet.\checkpoint(\Ledger.\utxos())$, for the current state of the \Ledger{}.
        \item \textbf{New \VoidNumber{s}}: All the \VoidNumber{s} in $P.\senders$ are unique, and no \VoidNumber{} in $P.\senders$ has already been stored in the $\Ledger.\VoidNumberSet$.
        \item \textbf{New \UTXO{s}}: All the \UTXO{s} in $P.\receivers$ are unique, and no \UTXO{} in $P.\receivers$ has already been stored on the ledger.
        \item \textbf{Verify \Transfer{}}: Check that $\NIZK.\verify_\vk(P.\sources \,||\, P.\senders \,||\, P.\receivers \,||\, P.\sinks, P.\pi) = \True$.
    \end{itemize}
\end{definition}

\begin{definition}[\Ledger{} \Transfer{} Update]
    After checking that a given \TransferPost{} $P$ is valid, the \Ledger{} updates its state by performing the following changes:
    \begin{itemize}
        \item \textbf{Public Updates}: All the relevant public accounts on the \PublicLedger{} are updated to reflect their new balances using the \Source{s} and \Sink{s} present in $P$.
        \item \textbf{Pool Update}: The \ShieldedAssetPool{} balance is updated to reflect the new shielded balances, increasing by the amount:
            \[\left(\sum_{a \in P.\sources} a.\VALUE\right) - \left(\sum_{a \in P.\sinks} a.\VALUE\right)\]
        \item \textbf{\UTXOSet{} Update}: The new \UTXO{s} are appended to the \UTXOSet{}.
        \item \textbf{\VoidNumberSet{} Update}: The new \VoidNumber{s} are appended to the \VoidNumberSet{}.
    \end{itemize}
\end{definition}

\lsubsection{Semantic Transactions}{abstract-semantic-transactions}

For \MantaPay{} participants to use the \Transfer{} protocol, they will need to keep track of the current state of their shielded assets and use them to build \TransferPost{s} to send to the \Ledger{}. The \emph{shielded balance} of any participant is the sum of the balances of their shielded assets, but this balance may be fragmented into arbitrarily many pieces, as each piece represents an independent asset that the participant received as the output of some \Transfer{}. To then spend a subset of their shielded balance, the participant would need to accumulate all of the relevant fragments into a large enough \emph{shielded asset} to spend all at once, building a collection of \TransferPost{s} to send to the \Ledger{}.

Any wallet implementation should see that their users need not keep track of this complexity themselves. Instead, like a public ledger, the notion of a \emph{transaction} between one participant and another should be viewed as a single action that the user can take, performing a withdrawl from their shielded balance. To describe such a \emph{semantic transaction}, we assume the existence of two transfer shapes\footnotemark{}: $\Mint$ with shape $(1, 0, 1, 0)$ and $\PrivateTransfer$ with shape $(0, N, N, 0)$ for some natural number $N > 1$.

\footnotetext{Other \Transfer{} accumulation algorithms are possible with different starting shapes.}

For a fixed spending key, $\sk : \SpendingKey$, and asset id, $\ID : \AssetId$, we are given a balance state, $\mathcal{B} : \FinSet\left(\KA.\PublicKey \times \AssetValue\right)$, a set of diversifier-balance pairs for unspent assets, a total balance to withdraw, $\total : \AssetValue$, and a receiving key $\rk : \ReceivingKey$. We can then compute 
\[\textsc{BuildTransaction}(\sk, \mathcal{B}, \total, \rk)\]
to receive a $\List(\TransferPost)$ to send to the ledger, representing the transfer of $\total$ to $\rk$.

\begin{algorithm*}
\caption{Semantic Transaction Algorithm}
\begin{algorithmic}
    \Procedure {BuildTransaction}{$\sk$, $\mathcal{B}$, $\total$, $\rk$}
        \State $B \gets \Sample(\total, \mathcal{B})$  \Comment{Samples pairs from $\mathcal{B}$ that total at least $\total$}
        \If{$\len(B) = 0$}
            \State \textsf{return} $[\,]$ \Comment{Insufficient Balance}
        \EndIf
        \State $P \gets [\,]$ \Comment{Allocate a new list for \TransferPost{s}}
        \While{$\len(B) > N$} \Comment{While there are enough pairs to make another \Transfer}
            \State $A \gets [\,]$
            \For{$b \in \next(B, N)$} \Comment{Get the next $N$ pairs from $B$}
                \State $S \gets \BuildSenders_\sk(b)$
                \State $[acc, zs...] \gets \BuildAccumulatorAndZeroes_\sk(S)$ \Comment{Build a new accumulator and zeroes}
                \State $P \gets P + \TransferPost(\Transfer([], S, [acc, zs...], []))$
                \State $(A, Z) \gets (A + (acc.\tilde{d}, acc.\asset.\VALUE), Z + zs)$ \Comment{Save $acc$ for the next loop, $zs$ for the end}
            \EndFor
            \State $B \gets A + \remainder(B, N)$
        \EndWhile
        \State $S \gets \PrepareZeroes_\sk(N, B, Z, P)$ \Comment{Use $Z$ and \Mint{s} to make $B$ go up to $N$ in size.}
        \State $R \gets \BuildReceiver_\sk(\rk, S)$
        \State $[c, zs...] \gets \BuildAccumulatorAndZeroes_\sk(S)$
        \State \textsf{return} $P + \TransferPost(\Transfer([], S, [R, c, zs...], []))$
    \EndProcedure
\end{algorithmic}
\end{algorithm*}

If all of the \Transfer{s} are accepted by the ledger, the balance state $\mathcal{B}$ should be updated accordingly, removing all of the pairs which were used in the \Transfer{}.

\lsection{Concrete Protocol}{concrete-protocol}

\TODO{other than cryptographic schemes, are there any implementation details we want to include here?}

\subsection{Concrete Cryptographic Schemes}

\begin{definition}[Commitment Scheme]
    For $\COM$, we use the \emph{Pedersen Commitment Scheme} with $256$ windows of size $4$ each.
\end{definition}

\begin{definition}[Hash Function]
    For $\CRH$, we use the \emph{Pedersen Hash Function} with $256$ windows of size $4$ each.
\end{definition}

\begin{definition}[Symmetric-Key Encryption Scheme]
    For $\SYM$, we use

    \TODO{symmetric-key encryption scheme: AES-GCM with magic-number nonce and no associated data}
\end{definition}

\begin{definition}[Key-Agreement Scheme]
    For $\KA$, we use

    \TODO{key-agreement scheme: x25519 elliptic curve Diffie-Hellman key exchange}
\end{definition}

\begin{definition}[Key-Diversification Scheme]
    For $\KDIV$, we use

    \TODO{key-diversification scheme: extension of key-agreement}
\end{definition}

\begin{definition}[Key-Derivation Function]
    For $\KDF$, we use

    \TODO{key-derivation function: Blake2s with magic-number salt}
\end{definition}

\begin{definition}[Hybrid Public Key Encryption]
    For $\HPKE$, we use

    \TODO{integrated encryption scheme: combination of above encryption protocols}
\end{definition}

\begin{definition}[Dynamic Cryptographic Accumulator]
    For $\DCA$, we use

    \TODO{dynamic cryptographic accumulator: Merkle Tree with Pedersen hashes (incremental tree for the ledger is an optimization since it only needs to know enough to compute the checkpoint as values are accumulated)}
\end{definition}

\begin{definition}[Non-Interactive Zero-Knowledge Proofs]
    For $\NIZK$, we use

    \TODO{non-interactive zero-knowledge proving system: Groth16 and/or PLONK}
\end{definition}

\lsection{Differences from $\MantaDAP$}{differences}

\subsection{Reusable Addresses}

\TODO{compare old one-time address protocol to reusable addresses and why reusable is better}

\subsection{\Transfer{} Circuit Unification}

\TODO{compare new single transfer circuit to the many old circuits}

\lsection{Acknowledgements}{acknowledgements}

\TODO{add acknowledgements}

\lsection{References}{references}
\bibliographystyle{plain}
\bibliography{ref}

\end{document}

