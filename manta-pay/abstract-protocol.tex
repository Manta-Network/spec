\lsection{Abstract Protocol}{abstract-protocol}

\subsection{Abstract Cryptographic Schemes}

In the following section, we outline the formal specifications for all of the \emph{cryptographic schemes} used in the \MantaPay{} protocol.

\begin{definitiontoc}{Hash Function}
    A \emph{hash function} $\HASH$ is defined by the schema:
    \begin{align*}
        \Input  &: \Type \\
        \Output &: \Type \\
        \hash   &: \Input \to \Output
    \end{align*}
    with the following properties:
    \begin{itemize}
        \item \textbf{Collision Resistance}: It is infeasible to find $a, b : \Input$ such that $a \ne b$ and $\hash(a) = \hash(b)$.
        \item \textbf{Pre-Image Resistance}: Given $y : \Output$, it is infeasible to find an $x : \Input$ such that $\hash(x) = y$.
        \item \textbf{Second Pre-Image Resistance}: Given $a : \Input$, it is infeasible to find another $b : \Input$ such that $a \ne b$ and $\hash(a) = \hash(b)$.
    \end{itemize}

    We can also ask that a hash function be \emph{binding} or \emph{hiding} as in the above \emph{Commitment Scheme} definition if we partition the $\Input$ space into a separate \Randomness{} and \Input{} space.

    \textbf{Notation}: For convenience, we may refer to $\HASH.\hash(x)$ by $\HASH(x)$.
\end{definitiontoc}

\begin{definitiontoc}{Commitment Scheme}
    A \emph{commitment scheme} $\COM$ is defined by the schema:
    \begin{align*}
        \Input                  &: \Type \\
        \Output                 &: \Type \\
        \Randomness             &: \Type \\
        \RandomnessDistribution &: \mathfrak{D}(\Randomness) \\
        \commit                 &: \Randomness \times \Input \to \Output
    \end{align*}
    with the following properties:
    \begin{itemize}
        \item \textbf{Binding}: It is infeasible to find an $x, y : \Input$ and $r, s: \Randomness$ such that $x \ne y$ and $\commit(r,x) = \commit(s,y)$.
        \item \textbf{Hiding}: For all $x, y : \Input$, the distributions $\set{\commit(r,x) \,|\, r \sim \RandomnessDistribution}$ and \\ $\set{\commit(r,y) \,|\, r \sim \RandomnessDistribution}$ are \emph{computationally indistinguishable}.
    \end{itemize}

    \textbf{Notation}: For convenience, we may refer to $\COM.\commit(r,x)$ by $\COM_r(x)$.
\end{definitiontoc}

\begin{definitiontoc}{Key-Derivation Function}
    A \emph{key-derivation function} $\KDF$ is defined by the schema:
    \begin{align*}
        \Input  &: \Type \\
        \Output &: \Type \\
        \derive &: \Input \to \Output
    \end{align*}
    \textbf{Notation}: For convenience, we may refer to $\KDF.\derive(x)$ by $\KDF(x)$.

    \textbf{NB}: This abstract definition covers many different cases of key related functions. The security properties of a specific $\KDF$ are outlined wherever it's used.
\end{definitiontoc}

\begin{definitiontoc}{Randomizable Key-Derivation Function}
    A \emph{randomizable key derivation function} $\rKDF$ extends a $\KDF$ scheme by adding the following randomization:
    \begin{align*}
        \Randomness             &: \Type \\
        \RandomnessDistribution &: \mathfrak{D}(\Randomness) \\
        \rand^I                 &: \Randomness \times \Input \to \Input \\
        \rand^O                 &: \Randomness \times \Output \to \Output
    \end{align*}
    where $\rand$ can be denoted without the type marker if the context is clear. The scheme has the following properties:
    \begin{itemize}
        \item \textbf{Random Derivation}: For all $x : \Input$ and $\alpha : \Randomness$, we have $\rand(\alpha, \derive(x)) = \derive(\rand(\alpha, x))$.
    \end{itemize}

    \textbf{Notation}: For convenience, we may refer to $\rand(\alpha, x)$ by $\rand_\alpha(x)$ and refer to $\rand_\alpha(\derive(x))$ by $\derive_\alpha(x)$.
\end{definitiontoc}

\begin{definitiontoc}{Key-Agreement Scheme}
    A \emph{key-agreement scheme} $\KA$ is defined by the schema:
    \begin{align*}
        \SecretKey    &: \Type \\
        \PublicKey    &: \Type \\
        \SharedSecret &: \Type \\
        \SecretKeyDistribution &: \mathfrak{D}(\SecretKey) \\
        \derive       &: \SecretKey \to \PublicKey \\
        \agree        &: \SecretKey \times \PublicKey \to \SharedSecret
    \end{align*}
    with the following properties:
    \begin{itemize}
        \item \textbf{Agreement}: For all $\sk_1, \sk_2 : \SecretKey$, $\agree(\sk_1, \derive(\sk_2)) = \agree(\sk_2, \derive(\sk_1))$
        \item \textbf{Passive Security}: Even if an adversary eavedrops on the network communication, she cannot forge the agreed secret unless she knows how to find a preimage for \derive{} which should be as hard as a known hard cryptography problem like the Diffie-Hellman Problem.
        \item \textbf{Known-key Security}: Suppose an adversary learned a shared secret from a past session, then, the adversary does not gain any additional information by combining the past key and public visible data for the purpose of deducing future shared secrets.
        \item \textbf{No Key Control}: The shared secrets are determined by both parties, neither party can control the outcome of the shared secret by restricting it to lie in some predetermined small set.
    \end{itemize}
\end{definitiontoc}

\begin{definitiontoc}{Message Authentication Code}
    A \emph{message authentication code} $\MAC$ is given by the schema:
    \begin{align*}
        \SecretKey &: \Type \\
        \Message   &: \Type \\
        \Tag       &: \Type \\
        \sign      &: \SecretKey \times \Message \to \Tag \\
        \verify    &: \SecretKey \times \Message \times \Tag \to \Bool
    \end{align*}
    with the following properties:
    \begin{itemize}
        \item \textbf{Completeness}: For all $\sk : \SecretKey$, $m : \Message$, we have that $\verify(\sk, m, \sign(\sk, m)) = \True$.
        \item \textbf{Unforgeability}: For any key $\sk : \SecretKey$ and efficient adversary $\mathcal{A}_\sk$ with oracle access to $\sign(\sk, \dash)$ the following probability is negligible:
            \[
                \Prob{
                    \verify(\sk, m, t) = \True
                }{
                    (m, t) \sim \mathcal{A}_\sk \\
                    m \not\in \mathcal{Q}(\mathcal{A}_\sk)
                }
            \]
            where $\mathcal{Q}(\mathcal{A}_\sk)$ denotes the set of queries that $\mathcal{A}_\sk$ makes to the oracle during its strategy.
    \end{itemize}

    \textbf{NB}: In the case that the secret key should not be known by the verifier, one can use a signature scheme instead.
\end{definitiontoc}

\begin{definitiontoc}{Signature Scheme}
    A \emph{signature scheme} $\SIG$ is defined by the schema:
    \begin{align*}
        \SecretKey    &: \Type \\
        \PublicKey    &: \Type \\
        \Message      &: \Type \\
        \Signature    &: \Type \\
        \derive       &: \SecretKey \to \PublicKey \\
        \sign         &: \SecretKey \times \Message \to \mathfrak{D}(\Signature) \\
        \verify       &: \PublicKey \times \Message \times \Signature \to \Bool
    \end{align*}
    with the following properties:
    \begin{itemize}
        \item \textbf{Completeness}: For all $\sk : \SecretKey$, $m : \Message$, and any signature $\sigma \sim \sign(\sk, m)$, we have that $\verify(\derive(\sk), m, \sigma) = \True$.
    \end{itemize}
\end{definitiontoc}

\begin{definitiontoc}{Symmetric-Key Encryption Scheme} \label{def:abstract-symm}
    An \emph{authenticated one-time symmetric-key encryption scheme} $\SYM$ is defined by the schema:
    \begin{align*}
        \Key &: \Type \\
        \Plaintext &: \Type \\
        \Ciphertext &: \Type \\
        \encrypt &: \Key \times \Plaintext \to \Ciphertext \\
        \decrypt &: \Key \times \Ciphertext \to \Option(\Plaintext)
    \end{align*}
    with the following properties:
    \begin{itemize}
        \item \textbf{Soundness}: For all keys $k : \Key$ and plaintexts $p : \Plaintext$, we have that
            \[\decrypt(k, \encrypt(k, p)) = \Some(p)\]
        \item \textbf{Security Requirement}: The symmetric-key encryption scheme must be one-time (INT-CTXT $\land$ IND-CPA)-secure \cite{BC2000AC}. ``One-time'' means that an honest protocol participant will almost surely encrypt only one message with a given key; however, the adversary could make many adaptive chosen ciphertext queries for a given key.
    \end{itemize}
\end{definitiontoc}

\begin{definitiontoc}{Message Digest Cipher}
    A \emph{message digest cipher} $\MDC$ is the following scheme:
    \begin{align*}
        \SecretKey &: \Type \\
        \mathbb{F} &: \Type \\
        H          &: \SecretKey \times \mathbb{F} \to \mathbb{F} \\
        \left(\dash\,\oplus\,\dash\right) &: \mathbb{F}^2 \to \mathbb{F} \\
        \left(\dash\,\ominus\,\dash\right) &: \mathbb{F}^2 \to \mathbb{F}
    \end{align*}
    where $H$ is a suitable Hash Function and $\oplus$ and $\ominus$ fulfill the following right-invertibility constraint for all $x, y : \mathbb{F}$
    \[(x \oplus y) \ominus y = x\]
    From these primitives we build a block-based encryption scheme. Given a plaintext $P : \mathbb{F}^k$ and a key schedule $K : \SecretKey^k$ we can encrypt to a ciphertext $C : \mathbb{F}^k$ by sequentially applying the following for each round:
    \[C_i := P_i \oplus H(K_i, C_{i-1})\]
    where on the first round $C_{-1}$ is some secret initialization vector. For decryption we use the reverse operation
    \[P_i := C_i \ominus H(K_i, C_{i-1})\]
    \textbf{NB}: This encryption scheme is not \emph{authenticating} in-and-of-itself and requires some strategy like Encrypt-then-MAC for authentication.
\end{definitiontoc}

\begin{definitiontoc}{Hybrid Public Key Encryption Scheme}
    A \emph{hybrid public key encryption scheme} \cite{irtf-cfrg-hpke-12} $\HPKE$ is an encryption scheme made up of a symmetric-key encryption scheme $\SYM$, a key-agreement scheme $\KA$, and a key-derivation function $\KDF$ to convert from $\KA.\SharedSecret$ to $\SYM.\Key$. We can define the following encryption and decryption algorithms:
    \begin{itemize}
        \item Encryption: Given an ephemeral secret key $\esk: \KA.\SecretKey$, a public key $\pk: \KA.\PublicKey$, and plaintext $p : \SYM.\Plaintext$, we produce the pair
            \[m : \KA.\PublicKey \times \SYM.\Ciphertext := \left(\KA.\derive(\esk), \SYM.\encrypt(\KDF(\KA.\agree(\esk, \pk)), p)\right)\]
        \item Decryption: Given a secret key $\sk : \KA.\SecretKey$, and an encrypted message, as above, $m := (\epk, c)$, we can decrypt $m$, producing the plaintext,
            \[p : \Option(\SYM.\Plaintext) := \SYM.\decrypt(\KDF(\KA.\agree(\sk, \epk)), c)\]
            which should decrypt successfully if the $\KA.\PublicKey$ that $m$ was encrypted with is the derived key of $\sk : \KA.\SecretKey$.
    \end{itemize}

    \textbf{Notation}: We denote the above \emph{encrypted message} type as $\Encrypted(\SYM.\Plaintext) := \KA.\PublicKey \times \SYM.\Ciphertext$, and the above two algorithms by
    \begin{align*}
        \encrypt &: \KA.\SecretKey \times \KA.\PublicKey \times \SYM.\Plaintext \to \Encrypted(\SYM.\Plaintext) \\
        \decrypt &: \KA.\SecretKey \times \KA.\PublicKey \times \SYM.\Ciphertext \to \Option(\SYM.\Plaintext)
    \end{align*}
    \textbf{Security Properties}: The HPKE constructed from $\KA$, $\KDF$, and $\SYM$ is required to be CCA2-secure and key-private \cite{BBDP01AC}. \\
\end{definitiontoc}

\begin{definitiontoc}{Authenticated Hybrid Public Key Encryption Scheme}
    An \emph{authenticated hybrid public encryption scheme} $\aHPKE$ is an authenticated encryption scheme built off of an $\HPKE$ and a $\MAC$ used in the following way:
    \[\aHPKE.\encrypt : \KA.\SecretKey \times \KA.\PublicKey \times \SYM.\Plaintext \to \AuthEncrypted(\SYM.\Plaintext)\]
    where $\AuthEncrypted$ is the encrypted note type:
    \[\AuthEncrypted(\SYM.\Plaintext) := \MAC.\Tag \times \Encrypted(\SYM.\Plaintext)\]
    and the tag is computed by applying the $\MAC$ onto the encrypted note:
    \[\TAG := \MAC(\sk, \HPKE.\encrypt(\esk, \pk))\]
\end{definitiontoc}

\begin{definitiontoc}{Dynamic Cryptographic Accumulator}
    A \emph{dynamic cryptographic accumulator} $\DCA$ is defined by the schema:
    \begin{align*}
        \Item    &: \Type \\
        \Output  &: \Type \\
        \Witness &: \Type \\
        \StateT  &: \Type \\
        \current &: \StateT \to \Output \\
        \insertF &: \Item \times \StateT \to \StateT \\
        \prove   &: \Item \times \StateT \to \Option(\Output \times \Witness) \\
        \verify  &: \Item \times \Output \times \Witness \to \Bool
    \end{align*}
    with the following properties:
    \begin{itemize}
        \item \textbf{Unique Accumulated Values}: For any initial state $s : \StateT$ and any list of items $I : \List(\Item)$ we can generate the sequence of states:
            \[s_0 := s, \,\,\,\,\, s_{i + 1} := \insertF(I_i, s_i)\]
            Then, if we collect the accumulated values for these states, $z_i := \current(s_i)$, there should be exactly $\abs{I}$-many unique values, one for each state update.
        \item \textbf{Provable Membership}: For any initial state $s : \StateT$ and any list of items $I : \List(\Item)$ we can generate the sequences of states:
            \[s_0 := s, \,\,\,\,\, s_{i + 1} := \insertF(I_i, s_i)\]
            Then, if we collect the states $s_i$ into a set $S$, we have the following property for all $s \in S$ and $t \in I$,
            \[\Some(z, w) := \prove(t, s), \,\,\,\,\, \verify(t, z, w) = \True\]
    \end{itemize}
\end{definitiontoc}

\begin{definitiontoc}{Non-Interactive Zero-Knowledge Proving System}
    A \emph{non-interactive zero-knowledge proving system} $\NIZK$ is defined by the schema:
    \begin{align*}
        \Statement    &: \Type \\
        \ProvingKey   &: \Type \\
        \VerifyingKey &: \Type \\
        \PublicInput  &: \Type \\
        \SecretInput  &: \Type \\
        \Proof        &: \Type \\
        \keys         &: \Statement \to \mathfrak{D}(\ProvingKey \times \VerifyingKey) \\
        \prove        &: \Statement \times \ProvingKey \times \PublicInput \times \SecretInput \to \mathfrak{D}(\Option(\Proof)) \\
        \verify       &: \VerifyingKey \times \PublicInput \times \Proof \to \Bool
    \end{align*}
    \textbf{Notation}: We use the following notation for a $\NIZK$:
    \begin{itemize}
        \item We write the $\Statement$ and $\ProvingKey$ arguments of $\prove$ in the superscript and subscript respectively,
            \[\prove^P_\pk(x, w) := \prove(P, \pk, x, w)\]
        \item We write the $\VerifyingKey$ argument of $\verify$ in the subscript,
            \[\verify_\vk(x, \pi) := \verify(\vk, x, \pi)\]
        \item We say that $(x, w) : \PublicInput \times \SecretInput$ has the property of being a $\satisfying$ input whenever
            \[\satisfying^P_\pk(x, w) := \exists \pi : \Proof,\, \Some(\pi) \in \prove^P_\pk(x, w)\]
    \end{itemize}

    Every $\NIZK$ has the following properties for a fixed statement $P : \Statement$ and keys $(\pk, \vk) \sim \keys(P)$:

    \begin{itemize}
        \item \textbf{Completeness}: For all $(x, w) : \PublicInput \times \SecretInput$, if $\satisfying^P_\pk(x, w) = \True$ with proof witness $\pi$, then $\verify_\vk(x, \pi) = \True$.
        \item \textbf{Knowledge Soundness}: For any polynomial-size adversary $\mathcal{A}$,
            \[\mathcal{A} : \ProvingKey \times \VerifyingKey \to \mathfrak{D}(\PublicInput \times \Proof)\]
             there exists a polynomial-size extractor $\mathcal{E}_\mathcal{A}$
            \[\mathcal{E}_\mathcal{A} : \ProvingKey \times \VerifyingKey \to \mathfrak{D}(\SecretInput)\]
            such that the following probability is negligible:
            \[
                \Prob{
                    \satisfying^P_\pk(x, w) = \False \\
                    \verify_\vk(x, w) = \True
                }{
                    (\pk, \vk) \sim \keys(P) \\
                    (x, \pi) \sim \mathcal{A}(\pk, \vk) \\
                    w \sim \mathcal{E}_\mathcal{A}(\pk, \vk)
                }
            \]
        \item \textbf{Statistical Zero-Knowledge}: There exists a stateful simulator $\mathcal{S}$, such that for all stateful distinguishers $\mathcal{D}$, the difference between the following two probabilities is negligible:
            \[
                \Prob{
                    \satisfying^P_\pk(x, w) = \True \\
                    \mathcal{D}(\pi) = \True
                }{
                    (\pk, \vk) \sim \keys(P) \\
                    (x, w) \sim \mathcal{D}(\pk, \vk) \\
                    \Some(\pi) \sim \prove^P_\pk(x, w)
                }
                \,\,\text{and}\,\,
                \Prob{
                    \satisfying^P_\pk(x, w) = \True \\
                    \mathcal{D}(\pi) = \True
                }{
                    (\pk, \vk) \sim \mathcal{S}(P) \\
                    (x, w) \sim \mathcal{D}(\pk, \vk) \\
                    \pi \sim \mathcal{S}(x)
                }
            \]
        \item \textbf{Succinctness}: For all $(x, w) : \PublicInput \times \SecretInput$, if $\Some(\pi) \sim \prove(P, \pk, x, w)$, then $\abs{\pi} = \mathcal{O}(1)$, and $\verify(\vk, x, \pi)$ runs in time $\mathcal{O}(\abs{x})$.
    \end{itemize}
\end{definitiontoc}

\lsubsection{Addresses and Key Components}{addresses-and-key-components}

For the \Transfer{} protocol we use a multi-layered system of keys:

\begin{center}
    \vspace{1em}
    \begin{mdframed}[leftmargin=0.125\textwidth, rightmargin=0.125\textwidth]
        \begin{center}
            \begin{tikzcd}
                &  & \sk \arrow[lldd, "\rand_\alpha"'] \arrow[rrdd, "\derive"] & & & & & & \\
                & & & & & & & & \\
                \sk_\alpha \arrow[rrdd, "\derive"'] & & & & \ak \arrow[lldd, "\rand_\alpha"] \arrow[rr, "\KDF^\vk"] & & \vk \arrow[rr, "\agree_\textsf{D}"] & & (\textsf{D}, \pk_\textsf{D}) \\
                & & & & & & & & \\
                & & \ak_\alpha & & & & & &
\end{tikzcd}
        \end{center}
    \end{mdframed}
    \vspace{-1em}
    \captionof{figure}{Detailed Key Schedule for \MantaPay{}.}
\end{center}

Here we define each key and its function in the \Transfer{} protocol.

\begin{definition}[Spending Key]
    Given a key-agreement scheme $\KA$ with compatible randomized key-derivation function $\rKDF$ we have:
    \[\SpendingKey := \KA.\SecretKey\]

    which can be randomized by $\rKDF.\Randomness$. The spending key must also be compatible with a signature scheme $\SIG$ who's underlying key derivation matches $\KA$ and $\rKDF$. 
\end{definition}

\begin{definition}[Proof Authorizing Key]
    Given a key-agreement scheme $\KA$ with compatible randomized key-derivation function $\rKDF$ and with a signature scheme $\SIG$ we have:
    \[\ProofAuthorizingKey := \KA.\PublicKey\]

    where a given $\sk : \SpendingKey$ derives the proof-authorizing key by
    \[\ak := \KA.\derive(\sk)\]

    This key can be randomized by $\alpha : \rKDF.\Randomness$ to get
    \[\ak_\alpha := \rKDF.\rand_\alpha(\ak)\]

    which is also equal to the key-agreement derivation of the randomized secret key
    \[\ak_\alpha = \KA.\derive(\rKDF.\rand_\alpha(\sk))\]

    To authorize a message $m$, the owner of $\sk$ can perform the following signature algorithm:
    \[\sigma \sim \SIG.\sign(\rKDF.\rand_\alpha(\sk), m)\]

    which can then be verified against $\ak_\alpha$ with
    \[\SIG.\verify(\ak_\alpha, m, \sigma)\]

    \textbf{NB}: For the \Transfer{} protocol, the message will be the zero-knowlege proof of a valid transfer and any additional associated data and \Ledger{} payload.
\end{definition}

\begin{definition}[Viewing Key]
    Given a proof-authorizing key, we require a $\KDF^\vk$ of type
    \[\KDF^\vk : \ProofAuthorizingKey \to \ViewingKey\]
    where $\ViewingKey$ is of type $\KA.\SecretKey$ so that it can be available for the $\KA$ key-agreement scheme so that we have
    \[\vk := \KDF^\vk(\ak)\]
\end{definition}

\begin{definition}[Shielded Address]
    Given a viewing key which is the secret key for the key-agreement scheme $\KA$, the shielded address is given by randomly selecting a public key $\textsf{D} : \KA.\PublicKey$ and then performing $\KA.\agree$ against it:
    \[\pk_\textsf{D} := \KA.\agree_\textsf{D}(\vk)\]

    We return the pair as the shielded address: $\addr := (\textsf{D}, \pk_\textsf{D})$. We call the random element $\textsf{D}$ the \Diversifier{} for the shielded address $\addr$.
\end{definition}

\begin{definition}[Key Schedule]
    A $\KeySchedule$ is a collection of implementations of the following abstract cryptographic primitives as described in the above definitions:
    \begin{itemize}
        \item \textbf{Key-Agreement Scheme}: $\KA$
        \item \textbf{Randomized Key-Derivation Scheme}: $\rKDF$
        \item \textbf{Viewing Key Derivation Function}: $\KDF^\vk$
        \item \textbf{Proof Authorization Signature}: $\SIG$
    \end{itemize}
    with the following notational conventions:
    \begin{align*}
        \SpendingKey         &:= \KA.\SecretKey \\
        \ProofAuthorizingKey &:= \KA.\PublicKey \\
        \ViewingKey          &:= \KA.\SecretKey \\
        \Diversifier         &:= \KA.\PublicKey \\
        \ShieldedAddress     &:= \KA.\Diversifier \times \KA.\PublicKey
    \end{align*}
    with the following constraints:
    \begin{align*}
        \rKDF.\Input    &= \KA.\SecretKey \\
        \rKDF.\Output   &= \KA.\PublicKey \\
        \SIG.\SecretKey &= \KA.\SecretKey \\
        \SIG.\PublicKey &= \KA.\PublicKey \\
        \SIG.\derive    &= \KA.\derive
    \end{align*}
\end{definition}

\lsubsection{\Transfer{} Protocol}{transfer-protocol}

The \Transfer{} protocol is the fundamental abstraction in \MantaPay{} and facilitiates the valid transfer of \Asset{s} among participants while preserving their privacy. The \Transfer{} is made up of sub-components called \Sender{s} and \Receiver{s} which represent the private input and the private output of a transaction.\footnotemark{}\footnotetext{Note that they do not represent actual individual participants in a transaction, but instead just the data involved in the transaction.} To perform a \Transfer{}, a protocol participant gathers the \SpendingKey{s} they own, selects a subset of the \UTXO{s} they have still not spent (with a fixed \AssetId{}), collects \ShieldedAddress{es} from other participants for the outputs of the \Transfer{}, assigning each key a subset of the input \Asset{s}, and then builds a \Transfer{} object representing that transaction. From this \Transfer{} object, they construct a \TransferPost{} which they then send to the \Ledger{} to be validated, representing a completed state transition in the \Ledger{}, updating the \UTXOSet{} and \VoidNumberSet{}. The transformation from \Transfer{} to \TransferPost{} involves keeping the parts of the \Transfer{} that \emph{must} be known to the \Ledger{} and for the parts that \emph{should not} be known, substituting them for a \emph{zero-knowledge proof} representing the validity of the secret information known to the participant, and the \Transfer{} as a whole.

We begin by defining the cryptographic primitives involved in the \Transfer{} protocol:

\begin{definition}[Transfer Configuration]
    A \TransferConfiguration{} is a collection of implementations of the following abstract cryptographic primitives:
    \begin{itemize}
        \item \textbf{Key Schedule}: $\KeySchedule$
        \item \textbf{Incoming Authenticated Hybrid Public Key Encryption}: $\aHPKEin$
        \item \textbf{Outgoing Authenticated Hybrid Public Key Encryption}: $\aHPKEout$
        \item \textbf{UTXO Commitment Scheme}: $\COM^{\UTXO}$
        \item \textbf{Void Number Commitment Scheme}: $\COM^{\VN}$
        \item \textbf{Dynamic Cryptographic Accumulator}: $\DCA$
        \item \textbf{Zero-Knowledge Proving System}: $\NIZK$
    \end{itemize}
    with the following notational conventions:
    \begin{align*}
        \UTXO         &:= \COM^{\UTXO}.\Output \\
        \VoidNumber   &:= \COM^{\VN}.\Output \\
        \IncomingNote &:= \KeySchedule.\ShieldedAddress \times \COM^\UTXO.\Randomness \times \Asset \\
        \OutgoingNote &:= \Asset \\
        \UTXOSet      &:= \DCA
    \end{align*}
    and the following constraints:
    \begin{align*}
        \COM^{\UTXO}.\Input    &= \KeySchedule.\ShieldedAddress \times \Asset \\
        \COM^{\VN}.\Randomness &= \KeySchedule.\ProofAuthorizingKey \\
        \COM^{\VN}.\Input      &= \UTXO \\
        \UTXOSet.\Item         &= \UTXO \\
        \aHPKEin.\KA           &= \KeySchedule.\KA \\
        \aHPKEout.\KA           &= \KeySchedule.\KA \\
        \ValidTransfer         &: \NIZK.\Statement \\
    \end{align*}
    where \ValidTransfer{} is defined below.
\end{definition}

For the rest of this section, we assume the existence of a \TransferConfiguration{} and use the primitives outlined above explicitly. We also implicitly use the \KeySchedule{} and drop its prefix when refering to its members. We continue by defining the \Sender{} and \Receiver{} constructions as well as their public counterparts, the \SenderPost{} and \ReceiverPost{}.

\begin{definition}[\Transfer{} Sender]
    A \Sender{} is the following tuple:
    \begin{align*}
        \ak                       &: \ProofAuthorizingKey \\
        \alpha                    &: \rKDF.\Randomness \\
        \ak_\alpha                &: \KA.\PublicKey \\
        \textsf{D}                &: \Diversifier \\
        r                         &: \COM^\UTXO.\Randomness \\
        \asset                    &: \Asset \\
        \pkD                      &: \KA.\PublicKey \\
        \eskout                   &: \KA.\SecretKey \\
        (\tagout, \epkout, \Cout) &: \AuthEncrypted(\OutgoingNote) \\
        \cm                       &: \UTXO \\
        (z_\cm, \pi_\cm)          &: \UTXOSet.\MembershipProof \\
        \vn                       &: \VoidNumber
    \end{align*}

    A \Sender{}, $S$, is constructed from a proof authorizing key $\ak : \ProofAuthorizingKey$, a randomizer $\alpha : \rKDF.\Randomness$ and an encrypted message $(\tagin, \epkin, \Cin) : \AuthEncrypted(\IncomingNote)$ with the following algorithm:
    \begin{align*}
        \ak_\alpha                   &:= \rKDF.\rand_\alpha(\ak) \\
        \vk                          &:= \KDF^\vk(\ak) \\
        \Some(\textsf{D}, r, \asset) &:= \aHPKEin.\decrypt(\vk, \tagin, \epkin, \Cin) \\
        \pkD                         &:= \KA.\agree_\textsf{D}(\vk) \\
        \eskout                      &:\sim \KA.\SecretKeyDistribution \\
        (\tagout, \epkout, \Cout)    &:= \aHPKEout.\encrypt_\textsf{D}(\eskout, \pkD, \asset) \\
        \cm                          &:= \COM^{\UTXO}_{r}(\textsf{D}, \pkD, \asset) \\
        \Some(z_\cm, \pi_\cm)        &:= \UTXOSet.\prove(\cm) \\
        \vn                          &:= \COM^{\VN}_\ak(\cm)
    \end{align*}
\end{definition}

\begin{definition}[\Transfer{} Sender Post]
    A \SenderPost{} is the following tuple extracted from a \Sender{}:
    \begin{align*}
        \ak_\alpha                &: \KA.\PublicKey \\
        (\tagout, \epkout, \Cout) &: \AuthEncrypted(\OutgoingNote) \\
        z_\cm                     &: \UTXOSet.\Output \\
        \vn                       &: \VoidNumber
    \end{align*}
    which are the parts of a \Sender{} which should be \emph{posted} to the \Ledger{}.
\end{definition}

\begin{definition}[\Transfer{} Receiver]
    A \Receiver{} is the following tuple:
    \begin{align*}
        (\textsf{D}, \pkD)     &: \ShieldedAddress \\
        r                      &: \COM^\UTXO.\Randomness \\
        \asset                 &: \Asset \\
        \cm                    &: \UTXO \\
        \eskin                 &: \KA.\SecretKey \\
        (\tagin, \epkin, \Cin) &: \AuthEncrypted(\IncomingNote)
    \end{align*}
    
    A \Receiver{}, $R$, is constructed from a shielded address $(\textsf{D}, \pkD) : \ShieldedAddress$, an asset $\asset : \Asset$, and a \UTXO{}-commitment randomness $r : \COM^\UTXO.\Randomness$ with the following algorithm:
    \begin{align*}
        \cm                    &:= \COM^{\UTXO}_r(\textsf{D}, \pkD, \asset) \\
        \eskin                 &:\sim \KA.\SecretKeyDistribution \\
        (\tagin, \epkin, \Cin) &:= \aHPKEin.\encrypt_\textsf{D}(\eskin, \pkD, (\textsf{D}, r, \asset))
    \end{align*}
\end{definition}

\begin{definition}[\Transfer{} Receiver Post]
    A \ReceiverPost{} is the following tuple extracted from a \Receiver{}:
    \begin{align*}
        \cm                    &: \UTXO \\
        (\tagin, \epkin, \Cin) &: \AuthEncrypted(\IncomingNote)
    \end{align*}
    which are the parts of a \Receiver{} which should be \emph{posted} to the \Ledger{}.
\end{definition}

\begin{definition}[\Transfer{} Sources and Sinks]
    A \Source{} (or a \Sink{}) is an \Asset{} representing a public input (or output) of a \Transfer{}.
\end{definition}

\begin{definition}[\Transfer{} Object]
    A \Transfer{} is the following tuple:
    \begin{align*}
        \sources    &: \List(\Asset) \\
        \senders    &: \List(\Sender) \\
        \receivers  &: \List(\Receiver) \\
        \sinks      &: \List(\Asset)
    \end{align*}
    The \emph{shape} of a \Transfer{} is the following $4$-tuple of cardinalities of those sets
    \[\left(\abs{T.\sources}, \abs{T.\senders}, \abs{T.\receivers}, \abs{T.\sinks}\right)\]
\end{definition}

In order for a \Transfer{} to be considered \emph{valid}, it must adhere to the following constraints:

\begin{itemize}
    \item \textbf{Same Id}: All the \AssetId{s} in the \Transfer{} must be equal.
    \item \textbf{Balanced}: The sum of input \AssetValue{s} must be equal to the sum of output \AssetValue{s}.
    \item \textbf{Well-formed Senders}: All of the \Sender{s} in the \Transfer{} must be constructed according to the above \Sender{} definition.
    \item \textbf{Well-formed Receivers}: All of the \Receiver{s} in the \Transfer{} must be constructed according to the above \Receiver{} definition.
\end{itemize}

In order to prove that these constraints are satisfied for a given \Transfer{}, we build a zero-knowledge proof which will witness that the \Transfer{} is valid and should be accepted by the \Ledger{}. 

\begin{definition}[\Transfer{} Validity \Statement{}]\label{def:transfer-validity-statement}
    A transfer $T : \Transfer$ is considered \emph{valid} if and only if
    \begin{enumerate}
        \item All the \AssetId{s} in $T$ are equal:
            \[
                \abs{
                    \left(\bigcup_{a \in T.\sources} a.\ID \right)
                    \cup
                    \left(\bigcup_{S \in T.\senders} S.\asset.\ID \right)
                    \cup
                    \left(\bigcup_{R \in T.\receivers} R.\asset.\ID \right)
                    \cup
                    \left(\bigcup_{a \in T.\sinks} a.\ID \right)
                } = 1
            \]
        \item The sum of input \AssetValue{s} is equal to the sum of output \AssetValue{s}:
            \[
                \left(\sum_{a \in T.\sources} a.\VALUE\right)
                +
                \left(\sum_{S \in T.\senders} S.\asset.\VALUE\right)
                =
                \left(\sum_{R \in T.\receivers} R.\asset.\VALUE\right)
                +
                \left(\sum_{a \in T.\sinks} a.\VALUE\right)
            \]
        \item For all $S \in T.\senders$, the \Sender{} $S$ is well-formed:
            \begin{align*}
                \ak_\alpha                            &= \rKDF.\rand_\alpha(\ak) \\
                \vk                                   &= \KDF^\vk(\ak) \\
                \pkD                                  &= \KA.\derive_\textsf{D}(\vk) \\
                (\tagout, \epkout, \Cout)             &= \aHPKEout.\encrypt_\textsf{D}(\eskout, \pkD, \asset) \\
                \cm                                   &= \COM^{\UTXO}_{r}(\textsf{D}, \pkD, \asset) \\
                \UTXOSet.\verify(\cm, z_\cm, \pi_\cm) &= \True \\
                \vn                                   &= \COM^{\VN}_{\ak}(\cm)
            \end{align*}
        \item For all $R \in T.\receivers$, the \Receiver{} $R$ is well-formed:
            \begin{align*}
                \cm            &= \COM^{\UTXO}_{r}(\textsf{D}, \pkD, \asset) \\
                (\tagin, \epkin, \Cin) &= \aHPKEin.\encrypt_\textsf{D}(\eskin, (\textsf{D}, r, \asset))
            \end{align*}
    \end{enumerate}
    \textbf{Notation}: This statement is denoted $\ValidTransfer$ and is assumed to be expressible as a \Statement{} of \NIZK{}.
\end{definition}

\begin{definition}[\Transfer{} Post]
    A \TransferPost{} is the following tuple:
    \begin{align*}
        \sources    &: \List(\Source) \\
        \senders    &: \List(\SenderPost) \\
        \receivers  &: \List(\ReceiverPost) \\
        \sinks      &: \List(\Sink) \\
        \pi         &: \NIZK.\Proof 
    \end{align*}
    A \TransferPost{}, $P$, is constructed by assembling the zero-knowledge proof of \Transfer{} validity from a known proving key $\pk : \NIZK.\ProvingKey$ and a given $T : \Transfer$:
    \begin{align*}
        x             &:= \Transfer.\public(T) \\
        w             &:= \Transfer.\secret(T) \\
        \Some(\pi)    &\sim \NIZK.\prove^\ValidTransfer_\pk(x, w) \\
        P.\sources    &:= x.\sources \\
        P.\senders    &:= x.\senders \\
        P.\receivers  &:= x.\receivers \\
        P.\sinks      &:= x.\sinks \\
        P.\pi         &:= \pi
    \end{align*}
    where $\Transfer.\public$ returns \SenderPost{s} for each \Sender{} in $T$ and \ReceiverPost{s} for each \Receiver{} in $T$, keeping \Source{s} and \Sink{s} as they are, and $\Transfer.\secret$ returns all the rest of $T$ which is not part of the output of $\Transfer.\public$.
\end{definition}

Now that the prover has constructed the proof, the underlying spending keys need to authorize the transaction before it can be sent to the \Ledger{}.

\begin{definition}[Proof Authorization]
    Given a transfer post $T: \TransferPost{}$ and a set of spending keys $S = \set{(\sk_i, \alpha_i)}$ where $(\sk_i, \alpha_i)$ come from the $i$th spender associated to the $T.\senders_i$, we have the following signature:
    \[\Sigma := \set{\SIG.\sign(\rKDF.\rand_\alpha(\sk), T) | (\sk, \alpha) \in S}\]

    which can be verified by the ledger with 
    \[\forall_i\SIG.\verify(T.\senders_i.\ak_\alpha, T, \Sigma_i) = \True\]
\end{definition}

Now that the transfer post has been signed by the owners of the spending keys, it can be sent up to the \Ledger{}.

\begin{definition}[\Ledger{}-side \Transfer{} Validity]
    To check that $P$ represents a valid \Transfer{}, the ledger checks the following:
    \begin{itemize}
        \item \textbf{Signature Check}: All the signatures associated to the transactions are valid.
        \item \textbf{Public Withdraw}: All the public addresses corresponding to the \Asset{s} in $P.\sources$ have enough public balance (i.e. in the \PublicLedger{}) to withdraw the given \Asset{}.
        \item \textbf{Public Deposit}: All the public addresses corresponding to the \Asset{s} in $P.\sinks$ exist.
        \item \textbf{Current Accumulated State}: The $\UTXOSet.\Output$ stored in each $P.\senders$ is equal to current accumulated value, $\UTXOSet.\current(\Ledger.\utxos())$, for the current state of the \Ledger{}.
        \item \textbf{New \VoidNumber{s}}: All the \VoidNumber{s} in $P.\senders$ are unique, and no \VoidNumber{} in $P.\senders$ has already been stored in the $\Ledger.\VoidNumberSet$.
        \item \textbf{New \UTXO{s}}: All the \UTXO{s} in $P.\receivers$ are unique, and no \UTXO{} in $P.\receivers$ has already been stored on the ledger.
        \item \textbf{Verify \Transfer{}}: Check that $\NIZK.\verify_\vk(P.\sources \,||\, P.\senders \,||\, P.\receivers \,||\, P.\sinks, P.\pi) = \True$.
    \end{itemize}
\end{definition}

\begin{definition}[\Ledger{} \Transfer{} Update]
    After checking that a given \TransferPost{} $P$ is valid, the \Ledger{} updates its state by performing the following changes:
    \begin{itemize}
        \item \textbf{Public Updates}: All the relevant public accounts on the \PublicLedger{} are updated to reflect their new balances using the \Source{s} and \Sink{s} present in $P$.
        \item \textbf{\UTXOSet{} Update}: The new \UTXO{s} are appended to the \UTXOSet{}.
        \item \textbf{\VoidNumberSet{} Update}: The new \VoidNumber{s} are appended to the \VoidNumberSet{}.
    \end{itemize}
\end{definition}

\lsubsection{Batched Transactions}{abstract-batched-transactions}

For \MantaPay{} participants to use the \Transfer{} protocol, they will need to keep track of the current state of their shielded assets and use them to build \TransferPost{s} to send to the \Ledger{}. The \emph{shielded balance} of any participant is the sum of the balances of their shielded assets, but this balance may be fragmented into arbitrarily many pieces, as each piece represents an independent asset that the participant received as the output of some \Transfer{}. To then spend a subset of their shielded balance, the participant would need to accumulate all of the relevant fragments into a large enough \emph{shielded asset} to spend all at once, building a collection of \TransferPost{s} to send to the \Ledger{}.

\begin{algorithm*}
\caption{Batch Transaction Algorithm}
\begin{algorithmic}
    \Procedure {BuildTransaction}{$\sk$, $\mathcal{B}$, $\total$, $\addr$}
        \State $B \gets \Sample(\total, \mathcal{B})$  \Comment{Samples key-asset pairs from $\mathcal{B}$ whose asset total at least $\total$}
        \If{$\len(B) = 0$}
            \State \textsf{return} $[\,]$ \Comment{Insufficient Balance}
        \EndIf
        \State $P \gets [\,]$ \Comment{Allocate a new list for \TransferPost{s}}
        \While{$\len(B) > N$} \Comment{While there are enough pairs to make another \Transfer}
            \State $A \gets [\,]$
            \For{$b \in \next(B, N)$} \Comment{Get the next $N$ pairs from $B$}
                \State $S \gets \BuildSenders_\sk(b)$
                \State $[acc, zs...] \gets \BuildAccumulatorAndZeroes_\sk(S)$ \Comment{Build a new accumulator and zeroes}
                \State $P \gets P + \TransferPost(\Transfer([], S, [acc, zs...], []))$
                \State $(A, Z) \gets (A + (acc.\tilde{d}, acc.\asset.\VALUE), Z + zs)$ \Comment{Save $acc$ for the next loop, $zs$ for the end}
            \EndFor
            \State $B \gets A + \remainder(B, N)$
        \EndWhile
        \State $S \gets \PrepareZeroes_\sk(N, B, Z, P)$ \Comment{Use $Z$ and \Mint{s} to make $B$ go up to $N$ in size.}
        \State $R \gets \BuildReceiver_\sk(\addr, S)$
        \State $[c, zs...] \gets \BuildAccumulatorAndZeroes_\sk(S)$
        \State \textsf{return} $P + \TransferPost(\Transfer([], S, [R, c, zs...], []))$
    \EndProcedure
\end{algorithmic}
\end{algorithm*}

Any wallet implementation should see that their users need not keep track of this complexity themselves. Instead, like a public ledger, the notion of a \emph{transaction} between one participant and another should be viewed as a single (atomic) action that the user can take, performing a withdrawl from their shielded balance. To describe such a \emph{semantic transaction}, we assume the existence of two transfer shapes\footnotemark{}: $\Mint$ with shape $(1, 0, 1, 0)$ and $\PrivateTransfer$ with shape $(0, N, N, 0)$ for some natural number $N > 1$.

\footnotetext{Other \Transfer{} accumulation algorithms are possible with different starting shapes.}

For a fixed spending key, $\sk : \SpendingKey$, and asset id, $\ID : \AssetId$, we are given a balance state, $\mathcal{B} : \FinSet\left(\KA.\PublicKey \times \AssetValue\right)$, a set of key-asset pairs for unspent assets, a total balance to withdraw, $\total : \AssetValue$, and a shielded key $\addr : \ShieldedAddress$. We can then compute 
\[\textsc{BuildTransaction}(\sk, \mathcal{B}, \total, \addr)\]
to receive a $\List(\TransferPost)$ to send to the ledger, representing the transfer of $\total$ to $\addr$.

If all of the \Transfer{s} are accepted by the ledger, the balance state $\mathcal{B}$ should be updated accordingly, removing all of the pairs which were used in the \Transfer{}. Wallets should also handle the more complex case when only some of the \Transfer{s} succeed in which case they need to be able to continue retrying the transaction until they are finally resolved. Since the only \Transfer{} which sends \Asset{s} out of the control of the user is the last one (and it recursively depends on the previous \Transfer{s}), then it is safe to continue from a partially resolved state with a simple retry of the $\textsc{BuildTransaction}$ algorithm.
